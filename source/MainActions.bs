import "pkg:/components/manager/ViewCreator.bs"
import "pkg:/source/api/Items.bs"
import "pkg:/source/enums/CollectionType.bs"
import "pkg:/source/enums/ItemType.bs"
import "pkg:/source/enums/ResumePopupAction.bs"
import "pkg:/source/enums/String.bs"
import "pkg:/source/utils/misc.bs"
import "pkg:/source/utils/multiserver.bs"

namespace MainAction
    sub onPlayButtonClicked(activeScene as object)
        startLoadingSpinner()
        activeScene.itemContent.id = chainLookup(activeScene, "selectedVideoStreamId")

        if isValid(activeScene.itemContent) and isValid(activeScene.itemContent.json)
        else
        end if

        ' Check if a specific Audio Stream was selected
        activeScene.itemContent.selectedAudioStreamIndex = chainLookup(activeScene, "selectedAudioStreamIndex") ?? 0

        playbackPositionTicks = chainLookup(activeScene, "itemContent.json.userdata.PlaybackPositionTicks") ?? 0

        ' Display playback options dialog
        if playbackPositionTicks > 0
            m.global.queueManager.callFunc("hold", activeScene.itemContent)
            playbackOptionDialog(playbackPositionTicks, activeScene.itemContent.json)
        else
            playItem(activeScene.itemContent, { method: "push", bypassNextPreferredAudioTrackIndexReset: true })
        end if

        if isChainValid(activeScene, "lastFocus.id") and isStringEqual(activeScene.lastFocus.id, "main_group")
            buttons = activeScene.findNode("buttons")
            if isValid(buttons)
                activeScene.lastFocus = activeScene.findNode("buttons")
            end if
        end if

        if isChainValid(activeScene, "lastFocus")
            activeScene.lastFocus.setFocus(true)
        end if
    end sub

    sub onPlayFromBeginningClicked(activeScene as object)
        ' Play from beginning - reset position to 0 and play
        startLoadingSpinner()
        activeScene.itemContent.id = chainLookup(activeScene, "selectedVideoStreamId")

        ' Check if a specific Audio Stream was selected
        activeScene.itemContent.selectedAudioStreamIndex = chainLookup(activeScene, "selectedAudioStreamIndex") ?? 0

        ' Reset playback position to 0
        if isChainValid(activeScene, "itemContent.json.userdata")
            activeScene.itemContent.json.userdata.PlaybackPositionTicks = 0
        end if

        ' Play the item from beginning
        playItem(activeScene.itemContent, { method: "push", bypassNextPreferredAudioTrackIndexReset: true })

        if isChainValid(activeScene, "lastFocus.id") and isStringEqual(activeScene.lastFocus.id, "main_group")
            buttons = activeScene.findNode("buttons")
            if isValid(buttons)
                activeScene.lastFocus = activeScene.findNode("buttons")
            end if
        end if

        if isChainValid(activeScene, "lastFocus")
            activeScene.lastFocus.setFocus(true)
        end if
    end sub

    sub onGoToSeriesClicked(activeScene as object)
        ' Navigate to the parent series from an episode
        if not isChainValid(activeScene, "itemContent.json.SeriesId") then return

        seriesId = activeScene.itemContent.json.SeriesId
        if not isValidAndNotEmpty(seriesId) then return

        itemServerInfo = getServerInfoFromItem(activeScene.itemContent)
        seriesServerData = invalid
        if isValid(itemServerInfo) and isValidAndNotEmpty(itemServerInfo.serverUrl) and isValidAndNotEmpty(itemServerInfo.authToken)
            seriesServerData = {
                serverUrl: itemServerInfo.serverUrl,
                userId: itemServerInfo.userId,
                authToken: itemServerInfo.authToken
            }
        end if

        CreateSeriesDetailsGroup(seriesId, seriesServerData)
    end sub

    sub onPartButtonClicked(activeScene as object)
        partData = {
            data: [{
                id: chainLookup(activeScene, "additionalParts.masterID"),
                type: "partselect",
                Track: {
                    description: "Part 1"
                }
            }]
        }

        selectedPart = chainLookup(activeScene, "selectedPart.id") ?? string.EMPTY

        i = 2
        for each part in chainLookup(activeScene, "additionalParts.parts.Items")
            part.type = "partselect"
            part.Track = {}
            part.Track.description = `Part ${i}`

            if selectedPart <> string.EMPTY
                if isStringEqual(part.id, selectedPart)
                    part.selected = true
                end if
            end if

            partData.data.push(part)

            i++
        end for

        m.global.sceneManager.callFunc("radioDialog", tr("Select Part"), partData)
        m.global.sceneManager.observeField("returnData", m.port)
    end sub

    sub onTrailerButtonClicked(activeScene as object)
        startLoadingSpinner()

        ' First, try to get local trailers
        if isChainValid(activeScene, "additionalParts.masterID")
            trailerData = api.users.GetLocalTrailers(m.global.session.user.id, activeScene.additionalParts.masterID)
        else
            trailerData = api.users.GetLocalTrailers(m.global.session.user.id, activeScene.id)
        end if

        ' If local trailers exist, play them
        if isValid(trailerData) and trailerData.count() > 0 and isValid(trailerData[0].id)
            playItem(trailerData, { method: "set", bypassNextPreferredAudioTrackIndexReset: true })
            stopLoadingSpinner()

            if isChainValid(activeScene, "lastFocus")
                activeScene.lastFocus.setFocus(true)
            end if
        else
            ' No local trailers available
            stopLoadingSpinner()

            ' Check if remote trailers exist
            itemContent = activeScene.itemContent
            if isValid(itemContent) and isChainValid(itemContent, "json.RemoteTrailers") and itemContent.json.RemoteTrailers.count() > 0

                ' Show message that remote trailers aren't supported yet
                dialog = CreateObject("roSGNode", "StandardMessageDialog")
                dialog.id = "OKDialog"
                dialog.title = "Trailer Not Available"
                dialog.message = ["This item only has remote trailers (YouTube) which are not currently supported on Roku. Local trailers stored on your Jellyfin server will play automatically."]
                dialog.buttons = ["OK"]
                m.scene.dialog = dialog
                ' The dialog obviously didn't handle it
                m.scene.dialog.observeField("buttonSelected", m.port)
            else

                if isChainValid(activeScene, "lastFocus")
                    activeScene.lastFocus.setFocus(true)
                end if
            end if
        end if
    end sub

    sub onWatchedButtonClicked(activeScene as object)
        movie = chainLookup(activeScene, "itemContent")
        if not isChainValid(movie, "watched") or not isValid(movie.id) then return

        if movie.watched
            setPlayed(movie.id, false)
        else
            setPlayed(movie.id, true)
            movieData = movie.json
            movieData.UserData.PlaybackPositionTicks = 0
            movie.json = movieData
        end if
        movie.watched = not movie.watched
    end sub

    sub onMyListButtonClicked(activeScene as object)
        movie = chainLookup(activeScene, "itemContent")
        if not isValid(movie.id) then return

        if activeScene.isInMyList
            MainAction.removeItemFromMyList(movie.id)
        else
            MainAction.addItemToMyList(movie.id)
        end if

        activeScene.isInMyList = not activeScene.isInMyList
    end sub

    sub onPlaylistButtonClicked(activeScene as object)
        startLoadingSpinner()

        movie = chainLookup(activeScene, "itemContent")
        if not isValid(movie.id) then return

        m.LoadPlaylistsTask = createObject("roSGNode", "LoadItemsTask")
        m.LoadPlaylistsTask.itemId = movie.id
        m.LoadPlaylistsTask.itemsToLoad = "playlists"
        m.LoadPlaylistsTask.observeFieldScoped("content", m.port)
        m.LoadPlaylistsTask.control = TaskControl.RUN
    end sub

    sub onFavoriteButtonClicked(activeScene as object)
        movie = chainLookup(activeScene, "itemContent")
        if not isChainValid(movie, "favorite") or not isValid(movie.id) then return

        ' Use task to avoid blocking the UI
        favoriteTask = createObject("roSGNode", "FavoriteItemsTask")
        favoriteTask.itemId = movie.id
        if movie.favorite
            favoriteTask.favTask = "unfavorite"
        else
            favoriteTask.favTask = "favorite"
        end if
        favoriteTask.control = "RUN"

        ' Update local state immediately for UI responsiveness
        movie.favorite = not movie.favorite
    end sub

    sub onEditSubtitlesButtonClicked(activeScene as object)
        subtitleSearchView = createObject("roSGNode", "SubtitleSearchView")
        subtitleSearchView.observeField("subtitleLanguageButtonSelected", m.port)
        subtitleSearchView.observeField("subtitleSearchButtonSelected", m.port)
        subtitleSearchView.observeField("subtitleToDelete", m.port)

        ' Set preferredSubtitleLanguage data so we can default the dropdown and popup correctly
        subtitleSearchView.cultures = api.localization.GetCultures()
        preferredSubtitleLanguage = chainLookup(m.global.session, "user.configuration.SubtitleLanguagePreference")
        if not isValidAndNotEmpty(preferredSubtitleLanguage)
            preferredSubtitleLanguage = "eng"
        end if

        subtitleSearchView.preferredSubtitleLanguage = preferredSubtitleLanguage

        ' Load the My Subtitles data now so it's up to date if user adds/deletes something it's updated
        ' If the data is bad, don't load the view
        metaData = ItemMetaData(activeScene.itemContent.id)
        if isValidAndNotEmpty(metaData)
            subtitleSearchView.itemContent = metaData
            m.global.sceneManager.callFunc("pushScene", subtitleSearchView)
        end if
    end sub

    sub onGoToSeriesButtonClicked(activeScene as object)
        CreateSeriesDetailsGroup(activeScene.itemContent.showID)
    end sub

    sub onGoToSeasonButtonClicked(activeScene as object)
        CreateSeasonDetailsGroupByID(activeScene.itemContent.LookupCI("showID"), activeScene.itemContent.LookupCI("seasonID"))
    end sub

    sub playItem(item as dynamic, params = {} as object)
        if not isValid(item)
            return
        end if

        startLoadingSpinner()

        playItemParams = {
            method: "push",
            bypassNextPreferredAudioTrackIndexReset: false,
            resetShuffle: false,
            position: -1
        }

        playItemParams.append(params)

        if playItemParams.bypassNextPreferredAudioTrackIndexReset
            m.global.queueManager.callFunc("bypassNextPreferredAudioTrackIndexReset")
        end if

        if playItemParams.resetShuffle
            m.global.queueManager.callFunc("resetShuffle")
        end if

        m.global.queueManager.callFunc("clear")
        m.global.queueManager.callFunc(playItemParams.method, item)

        if playItemParams.position <> -1
            m.global.queueManager.callFunc("setPosition", playItemParams.position)
        end if

        m.global.queueManager.callFunc("playQueue")
    end sub

    ' Check if this is a, "OK" Dialog and close if so
    sub closeOKDialog(msg)
        dialog = msg.getRoSGNode()
        if isStringEqual(dialog.id, "OKDialog")
            dialog.unobserveField("buttonSelected")
            dialog.close = true
        end if
    end sub

    sub setPlayed(itemID as string, isPlayed as boolean)
        group = m.global.sceneManager.callFunc("getActiveScene")
        if isValid(group)
            if isStringEqual(group.subtype(), "VisualLibraryScene")
                ' Don't reset selectedItem - this prevents re-selecting the same item
                ' group.selectedItem = invalid
                group.quickPlayNode = invalid
                itemFocused = group.callFunc("getItemFocused")
                itemFocused.callFunc("setWatched", isPlayed)
            end if
        end if

        if isPlayed
            date = CreateObject("roDateTime")
            dateStr = date.ToISOString()
            api.users.MarkPlayed(m.global.session.user.id, itemID, { "DatePlayed": dateStr, "PlaybackPositionTicks": 0 })
            return
        end if

        api.users.UnmarkPlayed(m.global.session.user.id, itemID)
    end sub

    sub addItemToFavorites(itemID as string)
        ' Use task to avoid blocking the UI
        favoriteTask = createObject("roSGNode", "FavoriteItemsTask")
        favoriteTask.itemId = itemID
        favoriteTask.favTask = "favorite"
        favoriteTask.control = "RUN"

        group = m.global.sceneManager.callFunc("getActiveScene")
        if isValid(group)
            if isStringEqual(group.subtype(), "home")
                group.callFunc("refresh")
            end if
        end if
    end sub

    sub removeItemFromFavorites(itemID as string)
        ' Use task to avoid blocking the UI
        favoriteTask = createObject("roSGNode", "FavoriteItemsTask")
        favoriteTask.itemId = itemID
        favoriteTask.favTask = "unfavorite"
        favoriteTask.control = "RUN"

        group = m.global.sceneManager.callFunc("getActiveScene")
        if isValid(group)
            if isStringEqual(group.subtype(), "home")
                group.callFunc("refresh")
            end if
        end if
    end sub

    sub addItemToMyList(itemID as string)
        data = api.GetUserViews({ "userId": m.global.session.user.id })
        if not isChainValid(data, "items") then return

        myListPlaylist = invalid

        for each item in data.LookupCI("items")
            if isStringEqual(item.LookupCI("CollectionType"), "playlists")
                myListPlaylist = api.items.Get({
                    "userid": m.global.session.user.id,
                    "includeItemTypes": "Playlist",
                    "nameStartsWith": "|My List|",
                    "parentId": item.LookupCI("id")
                })
                exit for
            end if
        end for

        ' My list playlist exists. Add item to it
        if isValid(myListPlaylist) and isValidAndNotEmpty(myListPlaylist.items)
            api.playlists.Add(myListPlaylist.items[0].LookupCI("id"), {
                ids: itemID,
                userid: m.global.session.user.id
            })

            group = m.global.sceneManager.callFunc("getActiveScene")
            if isValid(group)
                if isStringEqual(group.subtype(), "home")
                    group.callFunc("refresh")
                end if
            end if

            return
        end if

        ' My list playlist does not exist. Create it with this item
        api.playlists.Create({
            name: "|My List|",
            ids: [itemID],
            userid: m.global.session.user.id,
            mediatype: "Unknown",
            users: [
                {
                    userid: m.global.session.user.id,
                    canedit: true
                }
            ],
            ispublic: false
        })

        group = m.global.sceneManager.callFunc("getActiveScene")
        if isValid(group)
            if isStringEqual(group.subtype(), "home")
                group.callFunc("refresh")
            end if
        end if
    end sub

    ' Remove item from user's My List playlist
    sub removeItemFromMyList(itemID as string)

        data = api.GetUserViews({ "userId": m.global.session.user.id })
        if not isChainValid(data, "items") then return

        myListPlaylist = invalid

        for each item in data.LookupCI("items")
            if isStringEqual(item.LookupCI("CollectionType"), "playlists")
                myListPlaylist = api.items.Get({
                    "userid": m.global.session.user.id,
                    "includeItemTypes": "Playlist",
                    "nameStartsWith": "|My List|",
                    "parentId": item.LookupCI("id")
                })
                exit for
            end if
        end for

        ' My list playlist exists. Remove item from it
        if isValid(myListPlaylist) and isValidAndNotEmpty(myListPlaylist.items)
            api.playlists.Remove(myListPlaylist.items[0].LookupCI("id"), {
                entryIds: itemID
            })

            group = m.global.sceneManager.callFunc("getActiveScene")
            if isValid(group)
                if isStringEqual(group.subtype(), "home")
                    group.callFunc("refresh")
                end if
            end if
        end if
    end sub

    ' Remove item from playlist
    sub removeItemFromPlaylist(playlistID as string, itemID as string)
        if isValidAndNotEmpty(playlistID) and isValidAndNotEmpty(itemID)
            api.playlists.Remove(playlistID, {
                entryIds: itemID
            })
        end if
    end sub
end namespace
