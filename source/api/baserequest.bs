' Functions for making requests to the API
function buildParams(params = {} as object) as string
    ' Take an object of parameters and construct the URL query

    param_array = []
    for each field in params.items()
        item = ""
        if type(field.value) = "String" or type(field.value) = "roString"
            item = field.key + "=" + field.value.trim().EncodeUriComponent()
        else if type(field.value) = "roInteger" or type(field.value) = "roInt"
            item = field.key + "=" + stri(field.value).trim()
            'item = field.key + "=" + str(field.value).trim()
        else if type(field.value) = "roFloat"
            item = field.key + "=" + stri(int(field.value)).trim()
        else if type(field.value) = "LongInteger"
            item = field.key + "=" + field.value.toStr().trim()
        else if type(field.value) = "roArray"
            ' TODO handle array params
        else if type(field.value) = "roBoolean"
            if field.value
                item = field.key + "=true"
            else
                item = field.key + "=false"
            end if
        else if field.value = invalid
            item = field.key + "=null"
        else if field <> invalid
            item = field.key + "=" + field.value.EncodeUriComponent()
        end if

        if item <> "" then param_array.push(item)
    end for

    return param_array.join("&")
end function

function buildURL(path as string, params = {} as object) as dynamic
    serverURL = get_url()
    if serverURL = invalid then return invalid

    parsed_url = ParsedUrl(serverURL)
    full_url = `${parsed_url.proto}://${parsed_url.host}${parsed_url.port = "" ? "" : `:${parsed_url.port}`}${parsed_url.path}`

    ' some parts of the code include a query string with the path, so split it
    pathParts = path.split("?")
    realPath = pathParts[0]
    pathQuery = pathParts.count() > 1 ? pathParts[1] : ""

    ' Add intial '/' if path does not start with one
    full_url += realPath.startswith("/") ? realPath : `/${realPath}`

    ' append query string values
    hasQueryValue = isValidAndNotEmpty(parsed_url.query)
    hasPathQueryValue = isValidAndNotEmpty(pathQuery)
    hasParamsValue = isValidAndNotEmpty(params)

    if hasQueryValue or hasPathQueryValue or hasParamsValue
        full_url += "?"

        if hasQueryValue
            full_url += parsed_url.query
            if hasPathQueryValue or hasParamsValue
                full_url += "&"
            end if
        end if

        if hasPathQueryValue
            full_url += pathQuery
            if hasParamsValue
                full_url += "&"
            end if
        end if

        if hasParamsValue
            full_url += buildParams(params)
        end if
    end if

    return full_url
end function

function APIRequest(url as string, params = {} as object) as dynamic
    full_url = buildURL(url, params)
    if full_url = invalid then return invalid

    serverURL = m.global.session.server.url
    if serverURL = invalid then return invalid

    req = CreateObject("roUrlTransfer")
    req.setUrl(full_url)
    req = authRequest(req)
    ' SSL cert
    if serverURL.left(8) = "https://"
        setCertificateAuthority(req)
    end if

    return req
end function

function getJson(req)
    'req.retainBodyOnError(True)
    data = req.GetToString()
    if data = invalid or data = ""
        return invalid
    end if
    json = ParseJson(data)
    return json
end function

function postVoid(req, data = "" as string) as boolean
    req.setMessagePort(CreateObject("roMessagePort"))
    req.AddHeader("Content-Type", "application/json")
    req.AsyncPostFromString(data)
    resp = wait(30000, req.GetMessagePort())
    if type(resp) <> "roUrlEvent"
        return false
    end if

    if resp.GetResponseCode() = 200
        return true
    end if

    return false
end function

function headVoid(req) as boolean
    req.setMessagePort(CreateObject("roMessagePort"))
    req.AddHeader("Content-Type", "application/json")
    req.AsyncHead()
    resp = wait(30000, req.GetMessagePort())
    if type(resp) <> "roUrlEvent"
        return false
    end if

    if resp.GetResponseCode() = 200
        return true
    end if

    return false
end function

function getVoid(req) as boolean
    req.setMessagePort(CreateObject("roMessagePort"))
    req.AddHeader("Content-Type", "application/json")
    req.AsyncGetToString()
    resp = wait(30000, req.GetMessagePort())

    if type(resp) <> "roUrlEvent"
        return false
    end if

    if resp.GetResponseCode() = 200
        return true
    end if

    return false
end function

function postJson(req, data = "" as string)
    req.setMessagePort(CreateObject("roMessagePort"))
    req.AddHeader("Content-Type", "application/json")
    req.AsyncPostFromString(data)
    resp = wait(30000, req.GetMessagePort())
    if type(resp) <> "roUrlEvent"
        return invalid
    end if

    if resp.getString() = ""
        return invalid
    end if

    json = ParseJson(resp.GetString())

    return json
end function

function deleteVoid(req)
    req.setMessagePort(CreateObject("roMessagePort"))
    req.AddHeader("Content-Type", "application/json")
    req.SetRequest("DELETE")
    req.GetToString()

    return true
end function

function get_url()
    ' Validate the entire chain before accessing
    if not isValid(m.global) then return invalid
    if not isValid(m.global.session) then return invalid
    if not isValid(m.global.session.server) then return invalid

    serverURL = m.global.session.server.url
    if serverURL <> invalid
        if serverURL.right(1) = "/"
            serverURL = serverURL.left(serverURL.len() - 1)
        end if

        ' append http:// to the start if not specified
        if serverURL.left(7) <> "http://" and serverURL.left(8) <> "https://"
            serverURL = "http://" + serverURL
        end if
    end if
    return serverURL
end function

function getString(req)
    data = req.GetToString()
    return data
end function

function postString(req, data = "" as string)
    req.setMessagePort(CreateObject("roMessagePort"))
    req.AddHeader("Content-Type", "application/json")
    req.AsyncPostFromString(data)
    resp = wait(30000, req.GetMessagePort())
    if type(resp) <> "roUrlEvent"
        return invalid
    end if

    return resp.getString()
end function

function buildAuthHeader() as string
    QUOTE = Chr(34)
    auth = "MediaBrowser" + " Client=" + QUOTE + m.global.app.name + " Roku" + QUOTE
    auth = auth + ", Device=" + QUOTE + m.global.device.name + " (" + m.global.device.model + ")" + QUOTE
    auth = auth + ", Version=" + QUOTE + m.global.app.version + QUOTE
    auth = auth + ", DeviceId=" + QUOTE + m.global.device.serverDeviceName + QUOTE
    if isValid(m.global.session) and isValid(m.global.session.user) and isValid(m.global.session.user.authToken)
        auth = auth + ", Token=" + QUOTE + m.global.session.user.authToken + QUOTE
    end if
    return auth
end function

' sets the certificate authority by file path on the passed node
sub setCertificateAuthority(request as object) as void
    request.setCertificatesFile("common:/certs/ca-bundle.crt")
end sub

' Takes and returns a roUrlTransfer object after adding a Jellyfin "Authorization" header
function authRequest(req as object) as object
    req.AddHeader("Authorization", buildAuthHeader())
    return req
end function

function authRequestForServer(req as object, serverData as object) as object
    req.AddHeader("Authorization", buildAuthHeaderForServer(serverData))
    return req
end function

function buildAuthHeaderForServer(serverData as object) as string
    QUOTE = Chr(34)
    auth = "MediaBrowser" + " Client=" + QUOTE + m.global.app.name + " Roku" + QUOTE
    auth = auth + ", Device=" + QUOTE + m.global.device.name + " (" + m.global.device.model + ")" + QUOTE
    auth = auth + ", Version=" + QUOTE + m.global.app.version + QUOTE

    if isValidAndNotEmpty(serverData.userId)
        auth = auth + ", UserId=" + QUOTE + serverData.userId + QUOTE
    end if

    auth = auth + ", DeviceId=" + QUOTE + m.global.device.serverDeviceName + QUOTE

    if isValidAndNotEmpty(serverData.authToken)
        auth = auth + ", Token=" + QUOTE + serverData.authToken + QUOTE
    end if

    return auth
end function

function buildURLForServer(serverUrl as string, path as string, params = {} as object) as string
    if serverUrl = "" then return ""

    if serverUrl.right(1) = "/"
        serverUrl = serverUrl.left(serverUrl.len() - 1)
    end if

    if serverUrl.left(7) <> "http://" and serverUrl.left(8) <> "https://"
        serverUrl = "http://" + serverUrl
    end if

    pathParts = path.split("?")
    realPath = pathParts[0]
    pathQuery = ""
    if pathParts.count() > 1
        pathQuery = pathParts[1]
    end if

    if not realPath.startswith("/")
        realPath = "/" + realPath
    end if

    full_url = serverUrl + realPath

    hasPathQuery = isValidAndNotEmpty(pathQuery)
    hasParams = isValidAndNotEmpty(params)

    if hasPathQuery or hasParams
        full_url = full_url + "?"
        if hasPathQuery
            full_url = full_url + pathQuery
            if hasParams
                full_url = full_url + "&"
            end if
        end if
        if hasParams
            full_url = full_url + buildParams(params)
        end if
    end if

    return full_url
end function

function APIRequestForServer(serverUrl as string, userId as string, authToken as string, url as string, params = {} as object) as dynamic
    full_url = buildURLForServer(serverUrl, url, params)
    if full_url = "" then return invalid

    req = CreateObject("roUrlTransfer")
    req.setUrl(full_url)

    serverData = {
        serverUrl: serverUrl,
        userId: userId,
        authToken: authToken
    }
    req.AddHeader("Authorization", buildAuthHeaderForServer(serverData))

    if serverUrl.left(8) = "https://"
        setCertificateAuthority(req)
    end if

    return req
end function

function getServerInfoFromItem(item as object) as object
    if not isValid(item) then return invalid

    jsonData = item
    if isValid(item.json)
        jsonData = item.json
    end if

    if not isValid(jsonData._serverUrl) then return invalid
    if not isValid(jsonData._userId) then return invalid
    if not isValid(jsonData._authToken) then return invalid

    return {
        serverUrl: jsonData._serverUrl,
        userId: jsonData._userId,
        authToken: jsonData._authToken,
        serverId: jsonData._serverId,
        serverName: jsonData._serverName
    }
end function

function isMultiServerItem(item as object) as boolean
    itemServerData = getServerInfoFromItem(item)
    return isValid(itemServerData)
end function
