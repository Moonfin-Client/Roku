import "pkg:/source/constants/HomeRowItemSizes.bs"
import "pkg:/source/enums/KeyCode.bs"
import "pkg:/source/enums/TaskControl.bs"
import "pkg:/source/utils/misc.bs"
import "pkg:/source/utils/multiserver.bs"

const LOADING_WAIT_TIME = 2

' Helper function to get poster size based on user preference
function getPosterSize(preferWide = true as boolean) as object
    preferThumbnails = chainLookupReturn(m.global.session, "user.settings.ui.home.preferThumbnails", false)

    ' Convert to boolean if it's a string
    if type(preferThumbnails) = "String" or type(preferThumbnails) = "roString"
        preferThumbnails = (LCase(preferThumbnails) = "true")
    end if


    if preferThumbnails
        ' When prefer thumbnails is enabled, always use wide posters
        return homeRowItemSizes.WIDE_POSTER
    else
        ' When prefer thumbnails is disabled, use the preferWide parameter
        if preferWide
            return homeRowItemSizes.WIDE_POSTER
        else
            return homeRowItemSizes.MOVIE_POSTER
        end if
    end if
end function

' Helper function to check if Featured Media is enabled via toggle (not home sections)
function isFeaturedMediaEnabled() as boolean
    ' Check the media bar enabled toggle in Moonfin settings
    mediaBarEnabled = get_user_setting("ui.home.mediaBarEnabled")

    ' Default to true if not set
    if not isValid(mediaBarEnabled)
        return true
    end if

    ' Convert to boolean if it's a string
    if type(mediaBarEnabled) = "String" or type(mediaBarEnabled) = "roString"
        return (LCase(mediaBarEnabled) = "true")
    end if

    return mediaBarEnabled
end function

sub init()
    m.scene = m.top.getScene()

    m.overhang = getActiveNav(m.scene)
    if isValid(m.overhang)
        m.overhang.isVisible = true
    end if

    ' Hide the row counter to prevent flicker. We'll show it once loading timer fires
    m.top.showRowCounter = [false]

    m.top.content = CreateObject("roSGNode", "ContentNode")

    ' Initialize libraryData to prevent access before loading
    m.libraryData = []
    m.filteredLatest = []

    m.loadingTimer = createObject("roSGNode", "Timer")
    m.loadingTimer.duration = LOADING_WAIT_TIME
    m.loadingTimer.observeField("fire", "loadingTimerComplete")

    updateSize()

    m.top.setfocus(true)

    m.top.observeField("rowItemSelected", "itemSelected")

    ' Load the Libraries from API via task
    m.LoadLibrariesTask = createObject("roSGNode", "LoadItemsTask")
    m.LoadLibrariesTask.observeField("content", "onLibrariesLoaded")

    ' Initialize task storage - tasks will be created on-demand
    m.contentTasks = {}
    m.multiServerTasks = {}
end sub

sub loadLibraries()
    m.LoadLibrariesTask.control = "RUN"
end sub

' getOrCreateTask: Lazily creates and returns a LoadItemsTask for the given type
'
' @param {string} taskType - Type of task to create (e.g., "continue", "nextUp", "favorites")
' @return {object} The task node
function getOrCreateTask(taskType as string) as object
    ' Check if task already exists
    if m.contentTasks.DoesExist(taskType)
        return m.contentTasks[taskType]
    end if

    ' Create new task on-demand
    task = createObject("roSGNode", "LoadItemsTask")
    task.itemsToLoad = taskType
    m.contentTasks[taskType] = task

    return task
end function

' getTaskContentAndCleanup: Retrieves content from a task and cleans up its observers
'
' @param {string} taskType - Type of task to retrieve content from
' @return {object} The content from the task
function getTaskContentAndCleanup(taskType as string) as object
    if not m.contentTasks.doesExist(taskType)
        return invalid
    end if

    task = m.contentTasks[taskType]
    itemData = task.content
    task.unobserveField("content")
    task.content = []

    return itemData
end function

sub updateSize()
    ' Translation is set in Home.xml, don't override it here
    itemHeight = 380

    'Set width of Rows to cut off at edge of Safe Zone
    m.top.itemSize = [1703, itemHeight]

    ' spacing between rows (increased to prevent bottom text from being cut off)
    m.top.itemSpacing = [0, 110]

    ' spacing between items in a row
    m.top.rowItemSpacing = [20, 0]

    ' Default size to movie poster (portrait primary images)
    m.top.rowItemSize = homeRowItemSizes.MOVIE_POSTER

    m.top.visible = true
end sub

function getDefaultSection(index as integer) as string
    if index = 0 then return "resume"
    if index = 1 then return "recentlyreleased"
    if index = 2 then return "latestmedia"
    return "none"
end function

function getResolvedSectionName(index as integer) as string
    if m.useServerConfig
        userSection = m.global.session.user.settings["homesection" + index.toStr()]
    else
        userSection = get_user_setting("homeScreenSection" + index.toStr())
    end if

    if not isValid(userSection)
        return getDefaultSection(index)
    end if

    return LCase(userSection ?? "none")
end function

' processUserSections: Loop through user's chosen home section settings and generate the content for each row
'
sub processUserSections()
    m.expectedRowCount = 0
    m.processedRowCount = 0

    sessionUser = m.global.session.user

    m.useServerConfig = get_user_setting("homeRows.useServerConfig")
    if not isValid(m.useServerConfig)
        m.useServerConfig = false
    else if type(m.useServerConfig) = "String" or type(m.useServerConfig) = "roString"
        m.useServerConfig = (LCase(m.useServerConfig) = "true")
    end if

    ' Migration: Remove featuredmedia from local settings if present (run once)
    if not m.useServerConfig
        for i = 0 to 7
            userSection = get_user_setting("homeScreenSection" + i.toStr())
            if isValid(userSection) and LCase(userSection) = "featuredmedia"
                set_user_setting("homeScreenSection" + i.toStr(), "none")
            end if
        end for
    end if

    for i = 0 to 7
        sectionName = getResolvedSectionName(i)

        if sectionName = "latestmedia"
            ' Check if multi-server is enabled - if so, we estimate rows based on libraries per server
            if isMultiServerEnabled()
                sessions = getAllServerSessions()
                if sessions.count() > 0
                    m.expectedRowCount = m.expectedRowCount + (sessions.count() * 5)
                    continue for
                end if
            end if

            ' Single-server mode: expect 1 row per filtered media library
            excludeList = []
            if isValid(sessionUser.configuration) and isValid(sessionUser.configuration.LatestItemsExcludes)
                excludeList = sessionUser.configuration.LatestItemsExcludes
            end if

            ' Ensure libraryData is valid before accessing it
            if not isValid(m.libraryData)
                continue for
            end if

            m.filteredLatest = filterNodeArray(m.libraryData, "id", excludeList)
            for each latestLibrary in m.filteredLatest
                if latestLibrary.collectionType <> "boxsets" and latestLibrary.collectionType <> "livetv" and latestLibrary.json.CollectionType <> "Program"
                    m.expectedRowCount++
                end if
            end for
        else if sectionName <> "none"
            m.expectedRowCount++
        end if
    end for

    ' Add home sections in order based on user settings
    loadedSections = 0
    for i = 0 to 7
        sectionName = getResolvedSectionName(i)

        sectionLoaded = false
        if sectionName <> "none"
            sectionLoaded = addHomeSection(sectionName)
        end if

        ' Count how many sections with data are loaded
        if sectionLoaded then loadedSections++

        ' If 2 sections with data are loaded or we're at the end of the web client section data, consider the home view loaded
        if not m.global.app_loaded
            if loadedSections = 2 or i = 7
                m.top.signalBeacon("AppLaunchComplete") ' Roku Performance monitoring
                m.global.app_loaded = true
            end if
        end if
    end for

    if loadedSections = 0
        m.overhang.setfocus(true)
    end if

    ' Start the timer for creating the content rows before we set the cursor size
    m.loadingTimer.control = "start"
end sub

' onLibrariesLoaded: Handler when LoadLibrariesTask returns data
'
sub onLibrariesLoaded()
    ' save data for other functions
    m.libraryData = m.LoadLibrariesTask.content
    m.LoadLibrariesTask.unobserveField("content")
    m.LoadLibrariesTask.content = []

    processUserSections()
end sub

' getOriginalSectionIndex: Gets the index of a section from user settings and adds count of currently known latest media sections
'
' @param {string} sectionName - Name of section we're looking up
'
' @return {integer} indicating index of section taking latest media sections into account
function getOriginalSectionIndex(sectionName as string) as integer
    searchSectionName = LCase(sectionName).Replace(" ", "")

    sectionIndex = 0
    indexLatestMediaSection = 0

    for i = 0 to 7
        settingSectionName = getResolvedSectionName(i)

        if settingSectionName = "latestmedia"
            indexLatestMediaSection = i
        end if

        if settingSectionName = searchSectionName
            sectionIndex = i
        end if
    end for

    ' If the latest media section is before the section we're searching for, then we need to account for how many latest media rows there are
    addLatestMediaSectionCount = (indexLatestMediaSection < sectionIndex)

    if addLatestMediaSectionCount
        for i = sectionIndex to m.top.content.getChildCount() - 1
            sectionToTest = m.top.content.getChild(i)
            if LCase(Left(sectionToTest.title, 6)) = "latest"
                sectionIndex++
            end if
        end for
    end if

    return sectionIndex
end function

' removeHomeSection: Removes a home section from the home rows
'
' @param {string} sectionToRemove - Title property of section we're removing
sub removeHomeSection(sectionTitleToRemove as string)
    if not isValid(sectionTitleToRemove) then return

    sectionTitle = LCase(sectionTitleToRemove).Replace(" ", "")
    if not sectionExists(sectionTitle) then return

    sectionIndexToRemove = getSectionIndex(sectionTitle)

    m.top.content.removeChildIndex(sectionIndexToRemove)
    setRowItemSize()
end sub

' setRowItemSize: Loops through all home sections and sets the correct item sizes per row
'
sub setRowItemSize()
    if not isValid(m.top.content) then return

    homeSections = m.top.content.getChildren(-1, 0)
    newSizeArray = CreateObject("roArray", homeSections.count(), false)

    for i = 0 to homeSections.count() - 1
        newSizeArray[i] = isValid(homeSections[i].cursorSize) ? homeSections[i].cursorSize : homeRowItemSizes.MOVIE_POSTER
    end for
    m.top.rowItemSize = newSizeArray

    ' If we have processed the expected number of content rows, stop the loading timer and run the complete function
    if m.expectedRowCount = m.processedRowCount
        m.loadingTimer.control = "stop"
        loadingTimerComplete()
    end if
end sub

' loadingTimerComplete: Event handler for when loading wait time has expired
'
sub loadingTimerComplete()
    if not m.top.showRowCounter[0]
        ' Show the row counter to prevent flicker
        m.top.showRowCounter = [true]
    end if

    ' Signal that content has been loaded
    m.top.contentLoaded = true
end sub


' addHomeSection: Adds a new home section to the home rows.
'
' @param {string} sectionType - Type of section to add
' @return {boolean} indicating if the section was handled
function addHomeSection(sectionType as string) as boolean
    ' Check if merge setting is enabled
    mergeSetting = get_user_setting("ui.home.mergeContinueWatchingNextUp")
    mergeContinueWatching = (mergeSetting = "true")

    ' Poster size library items
    if sectionType = "livetv"
        createLiveTVRow()
        return true
    end if

    ' Poster size library items
    if sectionType = "smalllibrarytiles"
        createLibraryRow()
        return true
    end if

    ' Continue Watching items - handle merge logic
    if sectionType = "resume"
        if mergeContinueWatching
            ' Create merged row if not already created
            if not sectionExists(tr("Continue Watching"))
                createMergedContinueWatchingRow()
            end if
        else
            ' Create separate Continue Watching row
            createContinueWatchingRow()
        end if
        return true
    end if

    ' Continue Watching items
    if sectionType = "resumeaudio"
        createContinueListeningRow()
        return true
    end if

    ' Next Up items - skip if merged with Continue Watching
    if sectionType = "nextup"
        if mergeContinueWatching
            ' If merged row doesn't exist yet, create it now
            if not sectionExists(tr("Continue Watching"))
                createMergedContinueWatchingRow()
            end if
        else
            ' Create separate Next Up row
            createNextUpRow()
        end if
        return true
    end if

    ' Latest items in each library
    if sectionType = "latestmedia"
        createLatestInRows()
        return true
    end if

    ' Recently Released items
    if sectionType = "recentlyreleased"
        if isMultiServerEnabled()
            sessions = getAllServerSessions()
            if sessions.count() > 0
                createMultiServerRecentlyReleasedRow(sessions)
                return true
            end if
        end if
        createRecentlyReleasedRow()
        return true
    end if

    ' Favorite Items
    if sectionType = "favorites"
        if isMultiServerEnabled()
            sessions = getAllServerSessions()
            if sessions.count() > 0
                createMultiServerFavoritesRow(sessions)
                return true
            end if
        end if
        createFavoritesRow()
        return true
    end if

    ' My List Items
    if sectionType = "mylist"
        createMyListRow()
        return true
    end if

    ' Featured Media Carousel - now handled by separate toggle in Moonfin settings
    ' Skip creating a row for it, as it's controlled by ui.home.mediaBarEnabled
    if sectionType = "featuredmedia"
        m.processedRowCount++
        return false
    end if

    ' This section type isn't supported.
    ' Count it as processed since we aren't going to do anything else with it
    m.processedRowCount++
    return false
end function

' createLibraryRow: Creates a row displaying the user's libraries
'
sub createLibraryRow()
    m.processedRowCount++
    ' Ensure we have data
    if not isValidAndNotEmpty(m.libraryData) then return

    sectionName = tr("My Media")

    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(true)[0]
    row.cursorSize = getPosterSize(true)

    excludeList = []
    if isValid(m.global.session.user.configuration) and isValid(m.global.session.user.configuration.MyMediaExcludes)
        excludeList = m.global.session.user.configuration.MyMediaExcludes
    end if
    filteredMedia = filterNodeArray(m.libraryData, "id", excludeList)
    for each item in filteredMedia
        row.appendChild(item)
    end for

    ' Row already exists, replace it with new content
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    ' Row does not exist, insert it into the home view
    m.top.content.insertChild(row, getOriginalSectionIndex("smalllibrarytiles"))
    setRowItemSize()
end sub

' createLatestInRows: Creates a row displaying latest items in each of the user's libraries
'
sub createLatestInRows()
    multiServerEnabled = isMultiServerEnabled()

    if multiServerEnabled
        sessions = getAllServerSessions()

        if sessions.count() > 0
            createMultiServerLatestRows(sessions)
            return
        end if
    end if

    ' Ensure we have data
    if not isValidAndNotEmpty(m.libraryData)
        return
    end if


    ' create a Recently Added in row for each library
    for each lib in m.filteredLatest
        if not isStringEqual(lib.collectionType, "boxsets") and not isStringEqual(lib.collectionType, "livetv") and not isStringEqual(lib.json.CollectionType, "Program")
            sectionName = `${tr("Recently Added in")} ${lib.name}`

            ' Determine poster size based on content type and user preference
            imagesize = getPosterSize(false) ' Default to portrait, but respect thumbnail toggle

            if isValid(lib.json.CollectionType)
                if isStringEqual(lib.json.CollectionType, "movies")
                    imagesize = getPosterSize(false) ' Movies use portrait, or wide if thumbnails enabled
                else if isStringEqual(lib.json.CollectionType, "music")
                    imagesize = homeRowItemSizes.MUSIC_ALBUM
                end if
            end if

            if not sectionExists(sectionName)
                row = m.top.content.CreateChild("HomeRow")
                row.title = sectionName
                row.imageWidth = imagesize[0]
                row.cursorSize = imagesize
            end if

            try
                loadLatest = createObject("roSGNode", "LoadItemsTask")
                loadLatest.itemsToLoad = "latest"
                loadLatest.itemId = lib.id

                metadata = { "title": lib.name }
                metadata.Append({ "contentType": lib.json.CollectionType })
                loadLatest.metadata = metadata

                loadLatest.observeField("content", "updateLatestItems")
                loadLatest.control = TaskControl.RUN
            catch e
                removeHomeSection(sectionName)
                m.global.sceneManager.callFunc("standardDialog", `Error creating Recently Added rows`, { data: ["<p>" + `Error Message: ${e.message}` + "</p>"] })
            end try
        end if
    end for
end sub

' createRecentlyReleasedRow: Creates a row displaying recently released items sorted by premiere date
'
sub createRecentlyReleasedRow()
    sectionName = tr("Recently Released")

    if not sectionExists(sectionName)
        recentlyReleasedRow = m.top.content.CreateChild("HomeRow")
        recentlyReleasedRow.title = sectionName
        recentlyReleasedRow.imageWidth = getPosterSize(false)[0]
        recentlyReleasedRow.cursorSize = getPosterSize(false)
    end if

    ' Load the Recently Released Data (lazy task creation)
    task = getOrCreateTask("recentlyReleased")
    task.observeField("content", "updateRecentlyReleasedItems")
    task.control = "RUN"
end sub

' sectionExists: Checks if passed section exists in home row content
'
' @param {string} sectionTitle - Title of section we're checking for
'
' @return {boolean} indicating if the section currently exists in the home row content
function sectionExists(sectionTitle as string) as boolean
    if not isAllValid([sectionTitle, m.top.content]) then return false

    searchSectionTitle = LCase(sectionTitle).Replace(" ", "")

    homeSections = m.top.content.getChildren(-1, 0)

    for each section in homeSections
        if LCase(section.title).Replace(" ", "") = searchSectionTitle
            return true
        end if
    end for

    return false
end function

' getSectionIndex: Returns index of requested section in home row content
'
' @param {string} sectionTitle - Title of section we're checking for
'
' @return {integer} indicating index of request section
function getSectionIndex(sectionTitle as string) as integer
    if not isAllValid([sectionTitle, m.top.content]) then return -1

    searchSectionTitle = LCase(sectionTitle).Replace(" ", "")

    homeSections = m.top.content.getChildren(-1, 0)

    sectionIndex = homeSections.count()
    i = 0

    for each section in homeSections
        if LCase(section.title).Replace(" ", "") = searchSectionTitle
            sectionIndex = i
            exit for
        end if
        i++
    end for

    return sectionIndex
end function

' createLiveTVRow: Creates a row displaying the live tv now on section
'
sub createLiveTVRow()
    sectionName = tr("On Now")

    if not sectionExists(sectionName)
        row = m.top.content.CreateChild("HomeRow")
        row.title = sectionName
        row.imageWidth = getPosterSize(false)[0]
        row.cursorSize = getPosterSize(false)
    end if

    ' Load the On Now Data (lazy task creation)
    task = getOrCreateTask("onNow")
    task.observeField("content", "updateOnNowItems")
    task.control = "RUN"
end sub

' createContinueWatchingRow: Creates a row displaying items the user can continue watching
'
sub createContinueWatchingRow()
    sectionName = tr("Continue Watching")

    if not sectionExists(sectionName)
        row = m.top.content.CreateChild("HomeRow")
        row.title = sectionName
        row.imageWidth = getPosterSize(true)[0]
        row.cursorSize = getPosterSize(true)
    end if

    if isMultiServerEnabled() and hasMultipleLoggedInServers()
        createMultiServerContinueWatchingRow()
        return
    end if

    ' Load the Continue Watching Data (lazy task creation)
    task = getOrCreateTask("continue")
    task.observeField("content", "updateContinueWatchingItems")
    task.control = "RUN"
end sub

' createMultiServerContinueWatchingRow: Creates a row with continue watching from all servers
'
sub createMultiServerContinueWatchingRow()
    sessions = getAllServerSessions()
    if sessions.count() = 0
        task = getOrCreateTask("continue")
        task.observeField("content", "updateContinueWatchingItems")
        task.control = "RUN"
        return
    end if

    taskKey = "multiServerContinue"
    if not m.multiServerTasks.DoesExist(taskKey)
        task = CreateObject("roSGNode", "MultiServerTask")
        m.multiServerTasks[taskKey] = task
    else
        task = m.multiServerTasks[taskKey]
        task.callFunc("reset")
    end if

    task.sessions = sessions
    task.endpoint = "/Users/{userId}/Items/Resume"
    task.params = {
        Recursive: "true",
        SortBy: "DatePlayed",
        SortOrder: "Descending",
        Filters: "IsResumable",
        MediaTypes: "Video",
        EnableTotalRecordCount: "false",
        Limit: "25",
        EnableImageTypes: "Primary,Backdrop,Thumb",
        ImageTypeLimit: "1"
    }
    task.observeField("isComplete", "onMultiServerContinueWatchingComplete")
    task.control = "RUN"
end sub

' onMultiServerContinueWatchingComplete: Handler for multi-server continue watching results
'
sub onMultiServerContinueWatchingComplete()
    m.processedRowCount++
    taskKey = "multiServerContinue"
    if not m.multiServerTasks.DoesExist(taskKey) then return

    task = m.multiServerTasks[taskKey]
    task.unobserveField("isComplete")

    sectionName = tr("Continue Watching")
    results = task.results

    if not isValidAndNotEmpty(results)
        removeHomeSection(sectionName)
        return
    end if

    ' Sort by DatePlayed across all servers
    sortedResults = sortMultiServerResultsByDate(results, "UserData.LastPlayedDate")

    ' Create HomeData nodes from aggregated results
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    preferThumbnails = chainLookupReturn(m.global.session, "user.settings.ui.home.preferThumbnails", false)
    row.usePoster = not preferThumbnails

    if preferThumbnails
        row.imageWidth = homeRowItemSizes.WIDE_POSTER[0]
        row.cursorSize = homeRowItemSizes.WIDE_POSTER
    else
        row.imageWidth = homeRowItemSizes.MOVIE_POSTER[0]
        row.cursorSize = homeRowItemSizes.MOVIE_POSTER
    end if

    showServerName = hasMultipleLoggedInServers()

    for each item in sortedResults
        tmp = createHomeDataFromMultiServerItem(item, showServerName)
        if isValid(tmp)
            if isChainValid(item, "UserData.PlayedPercentage")
                tmp.PlayedPercentage = item.UserData.PlayedPercentage
            end if
            tmp.usePoster = row.usePoster
            tmp.imageWidth = row.imageWidth
            row.appendChild(tmp)
        end if
    end for

    ' Insert or replace row
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
    else
        m.top.content.insertChild(row, getOriginalSectionIndex("resume"))
    end if
    setRowItemSize()
end sub

' createMergedContinueWatchingRow: Creates a row displaying merged Continue Watching and Next Up items
'
sub createMergedContinueWatchingRow()
    sectionName = tr("Continue Watching")

    if not sectionExists(sectionName)
        row = m.top.content.CreateChild("HomeRow")
        row.title = sectionName
        row.imageWidth = getPosterSize(true)[0]
        row.cursorSize = getPosterSize(true)
    end if

    ' Load the Merged Continue Watching Data (lazy task creation)
    task = getOrCreateTask("mergedContinueWatching")
    task.observeField("content", "updateMergedContinueWatchingItems")
    task.control = "RUN"
end sub

' createContinueListeningRow: Creates a row displaying items the user can continue listening
'
sub createContinueListeningRow()
    sectionName = tr("Continue Listening")

    if not sectionExists(sectionName)
        row = m.top.content.CreateChild("HomeRow")
        row.title = sectionName
        row.imageWidth = getPosterSize(false)[0]
        row.cursorSize = getPosterSize(false)
    end if

    ' Load the Continue Listening Data (lazy task creation)
    task = getOrCreateTask("continueListening")
    task.observeField("content", "updateContinueListeningItems")
    task.control = "RUN"
end sub

' createNextUpRow: Creates a row displaying next episodes up to watch
'
sub createNextUpRow()
    sectionName = tr("Next Up")

    if not sectionExists(sectionName)
        row = m.top.content.CreateChild("HomeRow")
        row.title = sectionName
        row.imageWidth = getPosterSize(false)[0]
        row.cursorSize = getPosterSize(false)
    end if

    if isMultiServerEnabled() and hasMultipleLoggedInServers()
        createMultiServerNextUpRow()
        return
    end if

    task = getOrCreateTask("nextUp")
    task.observeField("content", "updateNextUpItems")
    task.control = "RUN"
end sub

' createMultiServerNextUpRow: Creates a row with next up episodes from all servers
'
sub createMultiServerNextUpRow()
    sessions = getAllServerSessions()
    if sessions.count() = 0
        task = getOrCreateTask("nextUp")
        task.observeField("content", "updateNextUpItems")
        task.control = "RUN"
        return
    end if

    taskKey = "multiServerNextUp"
    if not m.multiServerTasks.DoesExist(taskKey)
        task = CreateObject("roSGNode", "MultiServerTask")
        m.multiServerTasks[taskKey] = task
    else
        task = m.multiServerTasks[taskKey]
        task.callFunc("reset")
    end if

    ' Configure task for Next Up endpoint
    task.sessions = sessions
    task.endpoint = "/Shows/NextUp"
    task.params = {
        Recursive: "true",
        SortBy: "DatePlayed",
        SortOrder: "Descending",
        ImageTypeLimit: "1",
        UserId: "{userId}",
        DisableFirstEpisode: "false",
        Limit: "25",
        EnableTotalRecordCount: "false",
        EnableImageTypes: "Primary,Backdrop,Thumb"
    }
    task.observeField("isComplete", "onMultiServerNextUpComplete")
    task.control = "RUN"
end sub

' onMultiServerNextUpComplete: Handler for multi-server next up results
'
sub onMultiServerNextUpComplete()
    m.processedRowCount++
    taskKey = "multiServerNextUp"
    if not m.multiServerTasks.DoesExist(taskKey) then return

    task = m.multiServerTasks[taskKey]
    task.unobserveField("isComplete")

    sectionName = tr("Next Up")
    results = task.results

    if not isValidAndNotEmpty(results)
        removeHomeSection(sectionName)
        return
    end if

    ' Sort by DatePlayed across all servers
    sortedResults = sortMultiServerResultsByDate(results, "UserData.LastPlayedDate")

    ' Create HomeData nodes from aggregated results
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)
    row.usePoster = true

    ' Check if we should show server names
    showServerName = hasMultipleLoggedInServers()

    for each item in sortedResults
        tmp = createHomeDataFromMultiServerItem(item, showServerName)
        if isValid(tmp)
            tmp.usePoster = row.usePoster
            tmp.imageWidth = row.imageWidth
            row.appendChild(tmp)
        end if
    end for

    ' Insert or replace row
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
    else
        m.top.content.insertChild(row, getSectionIndex(sectionName))
    end if
    setRowItemSize()
end sub

' createMultiServerLatestRows: Creates "Recently Added in {Library} ({Server})" rows for each library on each server
'
' @param {array} sessions - Array of ServerUserSession objects
sub createMultiServerLatestRows(sessions as object)

    ' Use MultiServerTask to fetch libraries from all servers
    ' This must be done in a Task node, not directly in component code
    for each userSession in sessions
        ' Create a task to fetch libraries for this server
        taskKey = "multiServerLibraries_" + userSession.serverId
        if not m.multiServerTasks.DoesExist(taskKey)
            task = CreateObject("roSGNode", "MultiServerTask")
            m.multiServerTasks[taskKey] = task
        else
            task = m.multiServerTasks[taskKey]
            task.callFunc("reset")
        end if

        ' Configure task to fetch user views (libraries)
        task.sessions = [userSession]
        task.endpoint = "/Users/{userId}/Views"
        task.params = {}

        ' Store metadata for callback
        task.addFields({
            metadata: {
                userSession: userSession
            }
        })

        task.observeField("isComplete", "onMultiServerLibrariesLoaded")
        task.control = "RUN"
    end for

end sub

' onMultiServerLibrariesLoaded: Handler for library list loaded from a server
'
sub onMultiServerLibrariesLoaded(msg as object)
    node = msg.getRoSGNode()
    if not isValid(node)
        return
    end if

    if not isChainValid(node, "metadata.userSession")
        return
    end if

    userSession = node.metadata.userSession

    node.unobserveField("isComplete")

    results = node.results

    if not isValidAndNotEmpty(results)
        return
    end if

    ' Determine server name suffix
    serverSuffix = ""
    if hasMultipleLoggedInServers() and isValidAndNotEmpty(userSession.serverName)
        serverSuffix = " (" + userSession.serverName + ")"
    end if


    ' Create a row for each library
    for each item in results
        collectionType = ""
        if isValid(item.CollectionType) then collectionType = LCase(item.CollectionType)

        ' Skip boxsets, livetv, and programs
        if collectionType = "boxsets" or collectionType = "livetv" or collectionType = "program"
            continue for
        end if

        libraryName = item.Name
        if not isValidAndNotEmpty(libraryName) then libraryName = "Library"

        sectionName = tr("Recently Added in") + " " + libraryName + serverSuffix

        ' Determine poster size based on content type
        imagesize = getPosterSize(false)
        if collectionType = "music"
            imagesize = homeRowItemSizes.MUSIC_ALBUM
        end if

        ' Create placeholder row
        if not sectionExists(sectionName)
            latestRow = m.top.content.CreateChild("HomeRow")
            latestRow.title = sectionName
            latestRow.imageWidth = imagesize[0]
            latestRow.cursorSize = imagesize
        end if

        ' Create task to load latest items for this library
        taskKey = "multiServerLatest_" + userSession.serverId + "_" + item.Id
        if not m.multiServerTasks.DoesExist(taskKey)
            task = CreateObject("roSGNode", "MultiServerTask")
            m.multiServerTasks[taskKey] = task
        else
            task = m.multiServerTasks[taskKey]
            task.callFunc("reset")
        end if


        ' Configure task for Latest Items endpoint with parentId filter
        task.sessions = [userSession]
        task.endpoint = "/Items/Latest"
        task.params = {
            Limit: "25",
            ParentId: item.Id,
            EnableImageTypes: "Primary,Backdrop,Thumb",
            ImageTypeLimit: "1",
            EnableTotalRecordCount: "false"
        }

        ' Store metadata for the callback
        task.addFields({
            metadata: {
                sectionName: sectionName,
                collectionType: collectionType,
                serverName: userSession.serverName
            }
        })

        task.observeField("isComplete", "onMultiServerLatestPerLibraryComplete")
        task.control = "RUN"
    end for

end sub

' onMultiServerLatestPerLibraryComplete: Handler for per-library per-server latest items
'
sub onMultiServerLatestPerLibraryComplete(msg as object)
    node = msg.getRoSGNode()
    if not isValid(node)
        return
    end if

    ' Get metadata
    if not isChainValid(node, "metadata")
        return
    end if
    metadata = node.metadata

    m.processedRowCount++
    node.unobserveField("isComplete")

    sectionName = metadata.sectionName
    results = node.results


    if not isValidAndNotEmpty(results)
        removeHomeSection(sectionName)
        return
    end if

    ' Sort by DateCreated
    sortedResults = sortMultiServerResultsByDate(results, "DateCreated")

    ' Create the row
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.usePoster = true

    ' Set image size based on content type
    if metadata.collectionType = "music"
        row.imageWidth = homeRowItemSizes.MUSIC_ALBUM[0]
        row.cursorSize = homeRowItemSizes.MUSIC_ALBUM
    else
        posterSize = getPosterSize(false)
        row.imageWidth = posterSize[0]
        row.cursorSize = posterSize
    end if

    ' Don't show server name on individual items since it's in the row title
    for each item in sortedResults
        tmp = createHomeDataFromMultiServerItem(item, false)
        if isValid(tmp)
            tmp.usePoster = row.usePoster
            tmp.imageWidth = row.imageWidth
            row.appendChild(tmp)
        end if
    end for


    ' Insert or replace row
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
    else
        m.top.content.insertChild(row, getOriginalSectionIndex("latestmedia"))
    end if
    setRowItemSize()
end sub


' createMultiServerRecentlyReleasedRow: Creates an aggregated Recently Released row from all servers
'
' @param {array} sessions - Array of ServerUserSession objects
sub createMultiServerRecentlyReleasedRow(sessions as object)
    taskKey = "multiServerRecentlyReleased"
    if not m.multiServerTasks.DoesExist(taskKey)
        task = CreateObject("roSGNode", "MultiServerTask")
        m.multiServerTasks[taskKey] = task
    else
        task = m.multiServerTasks[taskKey]
        task.callFunc("reset")
    end if

    ' Configure task for Recently Released endpoint
    task.sessions = sessions
    task.endpoint = "/Users/{userId}/Items"
    task.params = {
        Recursive: "true",
        SortBy: "PremiereDate,ProductionYear,SortName",
        SortOrder: "Descending",
        IncludeItemTypes: "Movie,Series",
        Limit: "50",
        Fields: "PrimaryImageAspectRatio,Genres,Overview",
        EnableImageTypes: "Primary,Backdrop,Thumb",
        ImageTypeLimit: "1",
        EnableTotalRecordCount: "false"
    }
    task.observeField("isComplete", "onMultiServerRecentlyReleasedComplete")
    task.control = "RUN"
end sub

' onMultiServerRecentlyReleasedComplete: Handler for multi-server recently released results
'
sub onMultiServerRecentlyReleasedComplete()
    m.processedRowCount++
    taskKey = "multiServerRecentlyReleased"
    if not m.multiServerTasks.DoesExist(taskKey) then return

    task = m.multiServerTasks[taskKey]
    task.unobserveField("isComplete")

    sectionName = tr("Recently Released")
    results = task.results

    if not isValidAndNotEmpty(results)
        removeHomeSection(sectionName)
        return
    end if

    ' Create the row
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)

    ' Check if we should show server names
    showServerName = hasMultipleLoggedInServers()

    for each item in results
        tmp = createHomeDataFromMultiServerItem(item, showServerName)
        if isValid(tmp)
            tmp.usePoster = true
            tmp.imageWidth = row.imageWidth
            row.appendChild(tmp)
        end if
    end for

    ' Insert or replace row
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
    else
        m.top.content.insertChild(row, getOriginalSectionIndex("recentlyreleased"))
    end if
    setRowItemSize()
end sub

' createMultiServerFavoritesRow: Creates an aggregated Favorites row from all servers
'
' @param {array} sessions - Array of ServerUserSession objects
sub createMultiServerFavoritesRow(sessions as object)
    taskKey = "multiServerFavorites"
    if not m.multiServerTasks.DoesExist(taskKey)
        task = CreateObject("roSGNode", "MultiServerTask")
        m.multiServerTasks[taskKey] = task
    else
        task = m.multiServerTasks[taskKey]
        task.callFunc("reset")
    end if

    ' Configure task for Favorites endpoint
    sortField = m.global.session.user.settings["ui.home.favoritesSortField"] ?? "random"
    sortOrder = m.global.session.user.settings["ui.home.favoritesSortOrder"] ?? "Ascending"

    task.sessions = sessions
    task.endpoint = "/Users/{userId}/Items"
    task.params = {
        Filters: "IsFavorite",
        Recursive: "true",
        SortBy: sortField,
        SortOrder: sortOrder,
        EnableTotalRecordCount: "false",
        Limit: "25",
        EnableImageTypes: "Primary,Backdrop,Thumb",
        ImageTypeLimit: "1"
    }
    task.observeField("isComplete", "onMultiServerFavoritesComplete")
    task.control = "RUN"
end sub

' onMultiServerFavoritesComplete: Handler for multi-server favorites results
'
sub onMultiServerFavoritesComplete()
    m.processedRowCount++
    taskKey = "multiServerFavorites"
    if not m.multiServerTasks.DoesExist(taskKey) then return

    task = m.multiServerTasks[taskKey]
    task.unobserveField("isComplete")

    sectionName = tr("Favorites")
    results = task.results

    if not isValidAndNotEmpty(results)
        removeHomeSection(sectionName)
        return
    end if

    ' Create the row
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)

    ' Check if we should show server names
    showServerName = hasMultipleLoggedInServers()

    for each item in results
        ' Skip books and audio
        itemType = ""
        if isValid(item.Type) then itemType = LCase(item.Type)
        if itemType = "book" or itemType = "audio" then continue for

        tmp = createHomeDataFromMultiServerItem(item, showServerName)
        if isValid(tmp)
            usePoster = true
            if itemType = "episode" or itemType = "musicartist"
                usePoster = false
            end if
            tmp.usePoster = usePoster
            tmp.imageWidth = row.imageWidth
            row.appendChild(tmp)
        end if
    end for

    ' Insert or replace row
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
    else
        m.top.content.insertChild(row, getOriginalSectionIndex("favorites"))
    end if
    setRowItemSize()
end sub

' createMyListRow: Creates a row displaying items from the user's personal list
'
sub createMyListRow()
    sectionName = tr("My List")

    if not sectionExists(sectionName)
        row = m.top.content.CreateChild("HomeRow")
        row.title = sectionName
        row.imageWidth = getPosterSize(false)[0]
        row.cursorSize = getPosterSize(false)
    end if

    ' Load the My List Data (lazy task creation)
    task = getOrCreateTask("mylist")
    task.observeField("content", "updateMyListItems")
    task.control = "RUN"
end sub

' createFavoritesRow: Creates a row displaying items from the user's favorites list
'
sub createFavoritesRow()
    sectionName = tr("Favorites")

    if not sectionExists(sectionName)
        row = m.top.content.CreateChild("HomeRow")
        row.title = sectionName
        row.imageWidth = getPosterSize(false)[0]
        row.cursorSize = getPosterSize(false)
    end if

    ' Load the Favorites Data (lazy task creation)
    task = getOrCreateTask("favorites")
    task.observeField("content", "updateFavoritesItems")
    task.control = "RUN"
end sub

' updateHomeRows: Update function exposed to outside components
'
sub updateHomeRows()
    ' Hide the row counter to prevent flicker. We'll show it once loading timer fires
    m.top.showRowCounter = [false]
    processUserSections()
end sub

' updateFavoritesItems: Processes LoadFavoritesTask content. Removes, Creates, or Updates favorites row as needed
'
sub updateFavoritesItems()
    m.processedRowCount++
    itemData = getTaskContentAndCleanup("favorites")

    sectionName = tr("Favorites")

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    ' remake row using the new data
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)

    for each item in itemData
        usePoster = true

        if lcase(item.type) = "episode" or lcase(item.type) = "audio" or lcase(item.type) = "musicartist"
            usePoster = false
        end if

        item.usePoster = usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    m.top.content.insertChild(row, getSectionIndex(sectionName))
    setRowItemSize()
end sub

' updateMyListItems: Processes LoadMyListTask content. Removes, Creates, or Updates My List row as needed
'
sub updateMyListItems()
    m.processedRowCount++
    itemData = getTaskContentAndCleanup("mylist")

    sectionName = tr("My List")

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    ' remake row using the new data
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)

    for each item in itemData
        usePoster = true

        if lcase(item.type) = "episode" or lcase(item.type) = "audio" or lcase(item.type) = "musicartist"
            usePoster = false
        end if

        item.usePoster = usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    m.top.content.insertChild(row, getSectionIndex(sectionName))
    setRowItemSize()
end sub

sub buildContinueWatchingRow(taskKey as string)
    m.processedRowCount++
    itemData = getTaskContentAndCleanup(taskKey)

    sectionName = tr("Continue Watching")

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName

    preferThumbnails = m.global.session.user.settings["ui.home.preferThumbnails"] ?? false
    if type(preferThumbnails) = "String" or type(preferThumbnails) = "roString"
        preferThumbnails = (LCase(preferThumbnails) = "true")
    end if
    row.usePoster = not preferThumbnails

    if preferThumbnails
        row.imageWidth = homeRowItemSizes.WIDE_POSTER[0]
        row.cursorSize = homeRowItemSizes.WIDE_POSTER
    else
        row.imageWidth = homeRowItemSizes.MOVIE_POSTER[0]
        row.cursorSize = homeRowItemSizes.MOVIE_POSTER
    end if

    for each item in itemData
        if isChainValid(item, "json.UserData.PlayedPercentage")
            item.PlayedPercentage = item.json.UserData.PlayedPercentage
        end if

        item.usePoster = row.usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    m.top.content.insertChild(row, getOriginalSectionIndex("resume"))
    setRowItemSize()
end sub

sub updateContinueWatchingItems()
    buildContinueWatchingRow("continue")
end sub

sub updateMergedContinueWatchingItems()
    buildContinueWatchingRow("mergedContinueWatching")
end sub

' updateContinueListeningItems: Processes LoadContinueListeningTask content. Removes, Creates, or Updates continue listening row as needed
'
sub updateContinueListeningItems()
    m.processedRowCount++
    itemData = getTaskContentAndCleanup("continueListening")

    sectionName = tr("Continue Listening")

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    ' remake row using the new data
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)

    for each item in itemData
        if hasValidProperties(item, "json") and hasValidProperties(item.json, "UserData", "PlayedPercentage")
            item.PlayedPercentage = item.json.UserData.PlayedPercentage
        end if

        item.usePoster = row.usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    ' Row already exists, replace it with new content
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    ' Row does not exist, insert it into the home view
    m.top.content.insertChild(row, getOriginalSectionIndex("resumeaudio"))
    setRowItemSize()
end sub

' updateNextUpItems: Processes LoadNextUpTask content. Removes, Creates, or Updates next up row as needed
'
sub updateNextUpItems()
    m.processedRowCount++
    itemData = getTaskContentAndCleanup("nextUp")
    ' Stop the task for Next Up
    if m.contentTasks.doesExist("nextUp")
        m.contentTasks["nextUp"].control = "STOP"
    end if

    sectionName = tr("Next Up")

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    ' remake row using the new data
    row = CreateObject("roSGNode", "HomeRow")
    row.title = tr("Next Up")
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)
    row.usePoster = true ' Show series/movie posters

    for each item in itemData
        item.usePoster = row.usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    ' Row already exists, replace it with new content
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    ' Row does not exist, insert it into the home view
    m.top.content.insertChild(row, getSectionIndex(sectionName))
    setRowItemSize()
end sub

' updateLatestItems: Processes LoadItemsTask content. Removes, Creates, or Updates Recently Added in {library} row as needed
'
' @param {dynamic} msg - LoadItemsTask
sub updateLatestItems(msg)
    m.processedRowCount++
    itemData = msg.GetData()

    node = msg.getRoSGNode()
    node.unobserveField("content")
    node.content = []

    sectionName = tr("Recently Added in") + " " + node.metadata.title

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    imagesize = getPosterSize(false)

    if isValid(node.metadata.contentType)
        if LCase(node.metadata.contentType) = "movies"
            imagesize = getPosterSize(false)
        else if LCase(node.metadata.contentType) = "music"
            imagesize = homeRowItemSizes.MUSIC_ALBUM
        end if
    end if

    ' remake row using new data
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = imagesize[0]
    row.cursorSize = imagesize
    row.usePoster = true

    for each item in itemData
        item.usePoster = row.usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    if sectionExists(sectionName)
        ' Row already exists, replace it with new content
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    m.top.content.insertChild(row, getOriginalSectionIndex("latestmedia"))
    setRowItemSize()
end sub

' updateRecentlyReleasedItems: Processes LoadItemsTask content for recently released items
'
sub updateRecentlyReleasedItems()
    m.processedRowCount++
    itemData = getTaskContentAndCleanup("recentlyReleased")

    sectionName = tr("Recently Released")

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    ' Create row using the new data
    row = CreateObject("roSGNode", "HomeRow")
    row.title = sectionName
    row.imageWidth = getPosterSize(false)[0]
    row.cursorSize = getPosterSize(false)
    row.usePoster = true

    for each item in itemData
        item.usePoster = row.usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    ' Row already exists, replace it with new content
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    ' Row does not exist, insert it after latest media
    m.top.content.insertChild(row, getOriginalSectionIndex("latestmedia"))
    setRowItemSize()
end sub

' updateOnNowItems: Processes LoadOnNowTask content. Removes, Creates, or Updates Recently Added in on now row as needed
'
sub updateOnNowItems()
    m.processedRowCount++
    itemData = getTaskContentAndCleanup("onNow")

    sectionName = tr("On Now")

    if not isValidAndNotEmpty(itemData)
        removeHomeSection(sectionName)
        return
    end if

    ' remake row using the new data
    row = CreateObject("roSGNode", "HomeRow")
    row.title = tr("On Now")
    row.imageWidth = getPosterSize(true)[0]
    row.cursorSize = getPosterSize(true)

    for each item in itemData
        row.usePoster = false

        if (not isValid(item.thumbnailURL) or item.thumbnailURL = "") and isValid(item.json) and isValid(item.json.imageURL)
            item.thumbnailURL = item.json.imageURL
            row.usePoster = true
            row.imageWidth = getPosterSize(true)[0]
            row.cursorSize = getPosterSize(true)
        end if

        item.usePoster = row.usePoster
        item.imageWidth = row.imageWidth
        row.appendChild(item)
    end for

    ' Row already exists, replace it with new content
    if sectionExists(sectionName)
        m.top.content.replaceChild(row, getSectionIndex(sectionName))
        setRowItemSize()
        return
    end if

    ' Row does not exist, insert it into the home view
    m.top.content.insertChild(row, getOriginalSectionIndex("livetv"))
    setRowItemSize()
end sub

sub itemSelected()
    m.selectedRowItem = m.top.rowItemSelected
    ' Force field change notification even for same item by clearing first
    m.top.selectedItem = invalid
    m.top.selectedItem = m.top.content.getChild(m.top.rowItemSelected[0]).getChild(m.top.rowItemSelected[1])
end sub

function onKeyEvent(key as string, press as boolean) as boolean
    if press
        if key = KeyCode.PLAY
            itemToPlay = m.top.content.getChild(m.top.rowItemFocused[0]).getChild(m.top.rowItemFocused[1])
            if isValid(itemToPlay)
                m.top.quickPlayNode = itemToPlay
            end if
            return true
        end if

        if key = KeyCode.UP
            if m.top.rowItemFocused[0] = 0
                ' Check if Media Bar is enabled
                mediaBarEnabled = isFeaturedMediaEnabled()

                ' If Media Bar is enabled, let the Home component handle the UP key
                ' Otherwise, go to overhang as normal
                if not mediaBarEnabled
                    m.overhang.setfocus(true)

                    group = m.global.sceneManager.callFunc("getActiveScene")
                    if isValid(group)
                        group.lastFocus = m.overhang
                    end if

                    return true
                else
                    ' Return false to let parent (Home) handle the key event
                    return false
                end if
            end if
        end if

    end if

    group = m.global.sceneManager.callFunc("getActiveScene")
    if isValid(group)
        group.lastFocus = m.top
    end if
    return false
end function

function filterNodeArray(nodeArray as object, nodeKey as string, excludeArray as object) as object
    if excludeArray.IsEmpty() then return nodeArray

    newNodeArray = []
    for each node in nodeArray
        excludeThisNode = false
        for each exclude in excludeArray
            if node[nodeKey] = exclude
                excludeThisNode = true
            end if
        end for
        if excludeThisNode = false
            newNodeArray.Push(node)
        end if
    end for
    return newNodeArray
end function

' ============================================
' Multi-Server Helper Functions
' ============================================

' createHomeDataFromMultiServerItem: Creates a HomeData node from a multi-server API result
'
' @param {object} item - Raw API result with _serverId, _serverName, _serverUrl metadata
' @param {boolean} showServerName - Whether to append "(ServerName)" to the item name
' @return {object} HomeData node or invalid
function createHomeDataFromMultiServerItem(item as object, showServerName = false as boolean) as object
    if not isValid(item) then return invalid

    tmp = createSGNode("HomeData")

    ' Store the item ID
    itemId = ""
    if isValid(item.Id)
        itemId = item.Id
    else if isValid(item.id)
        itemId = item.id
    end if
    tmp.Id = itemId

    ' Store item name with optional server suffix
    itemName = ""
    if isValid(item.Name)
        itemName = item.Name
    else if isValid(item.name)
        itemName = item.name
    end if

    if showServerName and isValid(item._serverName)
        itemName = itemName + " (" + item._serverName + ")"
    end if
    tmp.name = itemName

    ' Store type
    if isValid(item.Type)
        tmp.type = item.Type
    else if isValid(item.type)
        tmp.type = item.type
    end if

    ' Build the JSON object with server metadata included
    jsonData = {
        Id: itemId,
        name: itemName,
        Type: item.Type,
        _serverId: item._serverId,
        _serverName: item._serverName,
        _serverUrl: item._serverUrl,
        _userId: item._userId,
        _authToken: item._authToken,
        SeriesName: item.SeriesName,
        SeriesId: item.SeriesId,
        SeasonId: item.SeasonId,
        ProductionYear: item.ProductionYear,
        Status: item.Status,
        EndDate: item.EndDate,
        ParentIndexNumber: item.ParentIndexNumber,
        IndexNumber: item.IndexNumber,
        IndexNumberEnd: item.IndexNumberEnd,
        OfficialRating: item.OfficialRating,
        CollectionType: item.CollectionType,
        ImageTags: item.ImageTags,
        UserData: item.UserData,
        ParentThumbItemId: item.ParentThumbItemId,
        ParentThumbImageTag: item.ParentThumbImageTag,
        ParentBackdropImageTags: item.ParentBackdropImageTags,
        ParentBackdropItemId: item.ParentBackdropItemId,
        SeriesPrimaryImageTag: item.SeriesPrimaryImageTag,
        BackdropImageTags: item.BackdropImageTags
    }
    tmp.json = jsonData

    ' Build image URLs using the item's server URL
    if isValidAndNotEmpty(item._serverUrl) and isValidAndNotEmpty(itemId)
        baseUrl = item._serverUrl
        if baseUrl.right(1) = "/"
            baseUrl = baseUrl.left(baseUrl.len() - 1)
        end if

        ' Build poster URL
        if isValid(item.ImageTags) and isValid(item.ImageTags.Primary)
            tmp.posterURL = baseUrl + "/Items/" + itemId + "/Images/Primary?tag=" + item.ImageTags.Primary + "&maxWidth=400"
        end if

        ' Build thumbnail URL (for episodes, use parent thumb if available)
        if isValid(item.ParentThumbItemId) and isValid(item.ParentThumbImageTag)
            tmp.thumbnailURL = baseUrl + "/Items/" + item.ParentThumbItemId + "/Images/Thumb?tag=" + item.ParentThumbImageTag + "&maxWidth=600"
        else if isValid(item.ImageTags) and isValid(item.ImageTags.Thumb)
            tmp.thumbnailURL = baseUrl + "/Items/" + itemId + "/Images/Thumb?tag=" + item.ImageTags.Thumb + "&maxWidth=600"
        else if isValid(item.ImageTags) and isValid(item.ImageTags.Primary)
            tmp.thumbnailURL = baseUrl + "/Items/" + itemId + "/Images/Primary?tag=" + item.ImageTags.Primary + "&maxWidth=600"
        end if

        ' Wide poster URL and backdrop URL (for full-screen backdrop)
        if isValid(item.BackdropImageTags) and item.BackdropImageTags.count() > 0
            tmp.widePosterURL = baseUrl + "/Items/" + itemId + "/Images/Backdrop?tag=" + item.BackdropImageTags[0] + "&maxWidth=600"
            tmp.backdropURL = baseUrl + "/Items/" + itemId + "/Images/Backdrop?tag=" + item.BackdropImageTags[0] + "&maxWidth=1920&maxHeight=1080&quality=90&blur=" + getHomeBackdropBlurAmount().toStr()
        else if isValid(item.ParentBackdropItemId) and isValid(item.ParentBackdropImageTags) and item.ParentBackdropImageTags.count() > 0
            tmp.widePosterURL = baseUrl + "/Items/" + item.ParentBackdropItemId + "/Images/Backdrop?tag=" + item.ParentBackdropImageTags[0] + "&maxWidth=600"
            tmp.backdropURL = baseUrl + "/Items/" + item.ParentBackdropItemId + "/Images/Backdrop?tag=" + item.ParentBackdropImageTags[0] + "&maxWidth=1920&maxHeight=1080&quality=90&blur=" + getHomeBackdropBlurAmount().toStr()
        end if
    end if

    return tmp
end function

' sortMultiServerResultsByDate: Sorts multi-server results by a date field (descending)
'
' @param {array} results - Array of items from multiple servers
' @param {string} dateField - Dot-notation path to date field (e.g., "UserData.LastPlayedDate")
' @return {array} Sorted array
function sortMultiServerResultsByDate(results as object, dateField as string) as object
    if not isValidAndNotEmpty(results) then return []

    ' Convert to array with sortable date values
    sortableItems = []
    for each item in results
        dateValue = getNestedValue(item, dateField)
        sortableItems.push({
            item: item,
            sortDate: dateValue
        })
    end for

    ' Simple bubble sort (sufficient for small arrays)
    n = sortableItems.count()
    for i = 0 to n - 2
        for j = 0 to n - i - 2
            ' Compare dates (ISO strings compare correctly alphabetically for descending)
            date1 = sortableItems[j].sortDate
            date2 = sortableItems[j + 1].sortDate

            ' Handle invalid dates
            if not isValid(date1) then date1 = ""
            if not isValid(date2) then date2 = ""

            ' Swap if date1 < date2 (we want descending order)
            if date1 < date2
                temp = sortableItems[j]
                sortableItems[j] = sortableItems[j + 1]
                sortableItems[j + 1] = temp
            end if
        end for
    end for

    ' Extract sorted items
    sortedResults = []
    for each sortable in sortableItems
        sortedResults.push(sortable.item)
    end for

    return sortedResults
end function

' getNestedValue: Gets a value from a nested object using dot notation
'
' @param {object} obj - Object to search
' @param {string} path - Dot-notation path (e.g., "UserData.LastPlayedDate")
' @return {dynamic} Value at path or invalid
function getNestedValue(obj as object, path as string) as dynamic
    if not isValid(obj) or path = "" then return invalid

    parts = path.split(".")
    current = obj

    for each part in parts
        if not isValid(current) then return invalid
        if type(current) <> "roAssociativeArray" then return invalid
        if not current.DoesExist(part) then return invalid
        current = current[part]
    end for

    return current
end function
