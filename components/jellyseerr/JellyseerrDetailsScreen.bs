import "pkg:/source/enums/ColorPalette.bs"
import "pkg:/source/utils/JellyseerrUtils.bs"
import "pkg:/source/utils/misc.bs"

sub init()
    m.backdrop = m.top.findNode("backdrop")
    m.backdropPrev = m.top.findNode("backdropPrev")
    m.poster = m.top.findNode("poster")
    m.statusBadgeGroup = m.top.findNode("statusBadgeGroup")
    m.statusBadge = m.top.findNode("statusBadge")
    m.statusBadgeBg = m.top.findNode("statusBadgeBg")
    m.titleLabel = m.top.findNode("titleLabel")
    m.metadataLabel = m.top.findNode("metadataLabel")
    m.taglineLabel = m.top.findNode("taglineLabel")
    m.buttonsGroup = m.top.findNode("buttonsGroup")
    m.overviewHeading = m.top.findNode("overviewHeading")
    m.overviewText = m.top.findNode("overviewText")
    m.metadataFactsGroup = m.top.findNode("metadataFactsGroup")
    m.castHeading = m.top.findNode("castHeading")
    m.castRow = m.top.findNode("castRow")
    m.keywordsSection = m.top.findNode("keywordsSection")
    m.keywordsHeading = m.top.findNode("keywordsHeading")
    m.keywordsContainer = m.top.findNode("keywordsContainer")
    m.keywordButtons = []
    m.focusedKeywordIndex = 0
    m.keywordRows = [] ' Array of arrays, each inner array is a row of keyword indices
    m.recommendationsHeading = m.top.findNode("recommendationsHeading")
    m.recommendationsRow = m.top.findNode("recommendationsRow")
    m.similarHeading = m.top.findNode("similarHeading")
    m.similarRow = m.top.findNode("similarRow")
    m.loadingLabel = m.top.findNode("loadingLabel")
    m.errorLabel = m.top.findNode("errorLabel")

    ' Scrolling viewport
    m.scrollViewport = m.top.findNode("scrollViewport")
    m.scrollContent = m.top.findNode("scrollContent")
    m.scrollOffset = 0
    m.scrollStep = 80

    m.apiTask = CreateObject("roSGNode", "JellyseerrAPITask")
    m.movieDetails = invalid
    m.tvDetails = invalid
    m.mediaInfo = invalid
    m.focusedElement = invalid
    m.previousFocusedElement = invalid
    m.buttons = []
    m.pending4kAfterHD = false
    m.pending4kUseAdvancedOptions = false

    ' Configure RowList item sizes for recommendations and similar rows
    m.recommendationsRow.rowItemSize = [180, 270]
    m.recommendationsRow.rowItemSpacing = [20, 0]
    m.recommendationsRow.focusBitmapUri = "pkg:/images/hd_focus.9.png"
    m.recommendationsRow.focusBitmapBlendColor = ColorPalette.WHITE
    m.recommendationsRow.focusFootprintBitmapUri = ""
    m.recommendationsRow.focusFootprintBlendColor = ColorPalette.TRANSPARENT
    m.recommendationsRow.drawFocusFeedback = true

    m.similarRow.rowItemSize = [180, 270]
    m.similarRow.rowItemSpacing = [20, 0]
    m.similarRow.focusBitmapUri = "pkg:/images/hd_focus.9.png"
    m.similarRow.focusBitmapBlendColor = ColorPalette.WHITE
    m.similarRow.focusFootprintBitmapUri = ""
    m.similarRow.focusFootprintBlendColor = ColorPalette.TRANSPARENT
    m.similarRow.drawFocusFeedback = true

    ' Setup observers
    m.top.observeFieldScoped("mediaItem", "onMediaItemSet")
    m.recommendationsRow.observeFieldScoped("rowItemSelected", "onRecommendationsItemSelected")
    m.similarRow.observeFieldScoped("rowItemSelected", "onSimilarItemSelected")
    m.castRow.observeFieldScoped("itemSelected", "onCastItemSelected")
    m.top.observeFieldScoped("restoreFocus", "onRestoreFocus")
    ' Smooth backdrop transitions
    m.backdrop.observeField("loadStatus", "onBackdropLoadStatusChange")
end sub

sub onRestoreFocus()
    m.top.setFocus(true)

    ' Try to restore to previously focused element first
    if m.previousFocusedElement <> invalid
        m.focusedElement = m.previousFocusedElement
        m.previousFocusedElement.setFocus(true)
        m.previousFocusedElement = invalid
    else if m.buttons.count() > 0
        focusSet = false
        m.focusedElement = m.buttonsGroup
        for each button in m.buttons
            if button.focusable
                button.setFocus(true)
                focusSet = true
                exit for
            end if
        end for
        if not focusSet
            if m.castRow.visible
                m.focusedElement = m.castRow
                m.castRow.setFocus(true)
            else
                m.buttonsGroup.setFocus(true)
            end if
        end if
    else if m.castRow.visible
        m.focusedElement = m.castRow
        m.castRow.setFocus(true)
    end if
end sub

' Cleanup observers and tasks when screen is hidden/popped
' Prevents memory leaks and orphaned callbacks
sub OnScreenHidden()
    if m.apiTask <> invalid
        m.apiTask.unobserveField("response")
        m.apiTask = invalid
    end if

    if m.similarApiTask <> invalid
        m.similarApiTask.unobserveField("response")
        m.similarApiTask = invalid
    end if

    if m.recommendationsApiTask <> invalid
        m.recommendationsApiTask.unobserveField("response")
        m.recommendationsApiTask = invalid
    end if

    if m.qualityDialog <> invalid
        m.qualityDialog.unobserveField("selectedQuality")
        m.qualityDialog.unobserveField("wasCancelled")
        m.qualityDialog = invalid
    end if

    if m.seasonDialog <> invalid
        m.seasonDialog.unobserveField("selectedSeasons")
        m.seasonDialog.unobserveField("wasCancelled")
        m.seasonDialog = invalid
    end if

    if m.successDialog <> invalid
        m.successDialog.unobserveField("buttonSelected")
        m.successDialog = invalid
    end if

    if m.cancelConfirmDialog <> invalid
        m.cancelConfirmDialog.unobserveField("buttonSelected")
        m.cancelConfirmDialog = invalid
    end if

    m.buttons = []
    m.keywordButtons = []
    m.keywordRows = []
end sub

sub onBackdropLoadStatusChange()
    loadStatus = m.backdrop.loadStatus

    if loadStatus = "ready"
        m.backdropPrev.uri = m.backdrop.uri
    end if
end sub

sub onMediaItemSet(event as object)
    mediaItem = event.getData()

    if mediaItem = invalid or mediaItem.tmdbId = invalid
        ShowError("Invalid media item")
        return
    end if

    m.mediaItem = mediaItem
    ShowLoading()
    UpdateBasicUI()
    LoadFullDetails()

    ' Refresh permissions if they're not set (for users who authenticated before permission tracking was added)
    RefreshPermissionsIfNeeded()
end sub

' Fetch permissions from Jellyseerr if they're currently 0
sub RefreshPermissionsIfNeeded()
    userPermissions = GetCurrentUserJellyseerrPermissions()

    if userPermissions = 0
        ' Permissions not set, fetch them from /auth/me
        m.permissionsTask = CreateObject("roSGNode", "JellyseerrAPITask")
        m.permissionsTask.request = {
            method: "GET",
            endpoint: "/api/v1/auth/me"
        }
        m.permissionsTask.observeField("response", "onPermissionsRefreshResponse")
        m.permissionsTask.control = "RUN"
    end if
end sub

sub onPermissionsRefreshResponse(event as object)
    response = event.getData()

    if response.success and response.data <> invalid
        permissions = 0
        if response.data.permissions <> invalid
            permissions = response.data.permissions
        end if

        userId = GetCurrentJellyfinUserId()
        if userId <> ""
            SetJellyseerrUserPermissions(userId, permissions)
        end if
    end if
end sub

sub UpdateBasicUI()
    item = m.mediaItem

    title = item.title
    if title = invalid then title = item.name
    year = GetYearFromDate(item.releaseDate)
    if year <> invalid
        m.titleLabel.text = title + " (" + year + ")"
    else
        m.titleLabel.text = title
    end if

    if item.overview <> invalid
        m.overviewText.text = item.overview
    end if

    if item.hdPosterUrl <> invalid
        m.poster.uri = item.hdPosterUrl
    end if
    if item.backdropUrl <> invalid
        m.backdrop.uri = item.backdropUrl
    else if item.hdBackdropUrl <> invalid
        m.backdrop.uri = item.hdBackdropUrl
    end if

    metaParts = []
    if year <> invalid
        metaParts.push(year)
    end if

    mediaType = "Movie"
    if item.mediaType = "tv" then mediaType = "TV Series"
    metaParts.push(mediaType)

    if item.rating <> invalid and item.rating <> ""
        metaParts.push("★ " + item.rating)
    end if

    m.metadataLabel.text = metaParts.join(" • ")
end sub

sub LoadFullDetails()
    mediaType = m.mediaItem.mediaType
    if mediaType = invalid then mediaType = "movie"

    tmdbId = m.mediaItem.tmdbId
    endpoint = "/api/v1/" + mediaType + "/" + tmdbId.toStr()

    ' Credits are included by default in the response, no query parameter needed

    m.apiTask.request = {
        method: "GET",
        endpoint: endpoint
    }

    m.apiTask.unobserveField("response")
    m.apiTask.observeField("response", "onFullDetailsResponse")
    m.apiTask.control = "RUN"
end sub

sub onFullDetailsResponse(event as object)
    response = event.getData()

    if not response.success
        errorMsg = "Failed to load details"
        if response.error <> invalid and type(response.error) = "roString"
            errorMsg = response.error
        end if
        ShowError(errorMsg)
        return
    end if

    data = response.data
    if data = invalid
        ShowError("Invalid response data")
        return
    end if
    if m.mediaItem.mediaType = "tv"
        m.tvDetails = data
    else
        m.movieDetails = data
    end if

    m.mediaInfo = data.mediaInfo

    UpdateFullUI()
    HideLoading()

    focusSet = false
    if m.buttons.count() > 0
        for each button in m.buttons
            if button.focusable
                button.setFocus(true)
                m.focusedElement = m.buttonsGroup
                focusSet = true
                exit for
            end if
        end for
    end if

    if not focusSet
        if m.castRow.visible
            m.focusedElement = m.castRow
            m.castRow.setFocus(true)
        else if m.recommendationsRow.visible
            m.focusedElement = m.recommendationsRow
            m.recommendationsRow.setFocus(true)
        else if m.similarRow.visible
            m.focusedElement = m.similarRow
            m.similarRow.setFocus(true)
        else
            m.focusedElement = m.buttonsGroup
            m.buttonsGroup.setFocus(true)
        end if
    end if

    LoadCastData()
    LoadRecommendationsContent()
    LoadSimilarContent()
end sub

sub UpdateFullUI()
    UpdateStatusBadge()
    UpdateMetadata()
    UpdateTagline()
    CreateKeywordsTags()
    CreateActionButtons()
    CreateMetadataFacts()
end sub

sub UpdateStatusBadge()
    status = invalid
    status4k = invalid

    if m.mediaInfo <> invalid
        if m.mediaInfo.status <> invalid then status = m.mediaInfo.status
        if m.mediaInfo.status4k <> invalid then status4k = m.mediaInfo.status4k
    end if

    hdDeclined = false
    fourKDeclined = false
    if m.mediaInfo <> invalid and m.mediaInfo.requests <> invalid
        for each request in m.mediaInfo.requests
            if request.is4k = false and request.status = 3 then hdDeclined = true
            if request.is4k = true and request.status = 3 then fourKDeclined = true
        end for
    end if

    ' Status: 1=unknown, 2=pending, 3=processing, 4=partial, 5=available, 6=blacklisted
    statusText = ""
    bgColor = "#6B7280"

    ' Determine badge text based on both HD and 4K statuses
    if hdDeclined and fourKDeclined
        statusText = "HD + 4K DECLINED"
        bgColor = "#EF4444" ' red-500
    else if fourKDeclined
        statusText = "4K DECLINED"
        bgColor = "#EF4444" ' red-500
    else if hdDeclined
        statusText = "HD DECLINED"
        bgColor = "#EF4444" ' red-500
    else if status = 6 and status4k = 6
        statusText = "HD + 4K BLACKLISTED"
        bgColor = "#DC2626" ' red-600
    else if status4k = 6
        statusText = "4K BLACKLISTED"
        bgColor = "#DC2626" ' red-600
    else if status = 6
        statusText = "HD BLACKLISTED"
        bgColor = "#DC2626" ' red-600
    else if status = 5 and status4k = 5
        statusText = "HD + 4K AVAILABLE"
        bgColor = "#22C55E" ' green-500
    else if status4k = 5
        statusText = "4K AVAILABLE"
        bgColor = "#22C55E" ' green-500
    else if status = 5
        statusText = "HD AVAILABLE"
        bgColor = "#22C55E" ' green-500
    else if status = 4 and status4k = 4
        statusText = "HD + 4K PARTIAL"
        bgColor = "#22C55E" ' green-500
    else if status4k = 4
        statusText = "4K PARTIAL"
        bgColor = "#22C55E" ' green-500
    else if status = 4
        statusText = "HD PARTIAL"
        bgColor = "#22C55E" ' green-500
    else if status = 3 and status4k = 3
        statusText = "HD + 4K PROCESSING"
        bgColor = "#6366F1" ' indigo-500
    else if status4k = 3
        statusText = "4K PROCESSING"
        bgColor = "#6366F1" ' indigo-500
    else if status = 3
        statusText = "HD PROCESSING"
        bgColor = "#6366F1" ' indigo-500
    else if status = 2 and status4k = 2
        statusText = "HD + 4K PENDING"
        bgColor = "#EAB308" ' yellow-500
    else if status4k = 2
        statusText = "4K PENDING"
        bgColor = "#EAB308" ' yellow-500
    else if status = 2
        statusText = "HD PENDING"
        bgColor = "#EAB308" ' yellow-500
    else if status = 1 and status4k = 1
        statusText = "HD + 4K UNKNOWN"
        bgColor = "#9CA3AF" ' gray-400
    else if status4k = 1
        statusText = "4K UNKNOWN"
        bgColor = "#9CA3AF" ' gray-400
    else if status = 1
        statusText = "HD UNKNOWN"
        bgColor = "#9CA3AF" ' gray-400
    else
        statusText = "NOT REQUESTED"
        bgColor = "#6B7280" ' gray-500
    end if

    m.statusBadge.text = statusText
    m.statusBadgeBg.blendColor = bgColor
    m.statusBadgeGroup.visible = true
end sub

sub UpdateMetadata()
    metaParts = []
    if m.movieDetails <> invalid and m.movieDetails.runtime <> invalid
        runtime = m.movieDetails.runtime
        hours = int(runtime / 60)
        minutes = runtime mod 60
        if hours > 0 and minutes > 0
            metaParts.push(hours.toStr() + "h " + minutes.toStr() + "m")
        else if hours > 0
            metaParts.push(hours.toStr() + "h")
        else if minutes > 0
            metaParts.push(minutes.toStr() + "m")
        end if
    end if

    genreList = []
    if m.movieDetails <> invalid and m.movieDetails.genres <> invalid
        for each genre in m.movieDetails.genres
            if genre.name <> invalid
                genreList.push(genre.name)
            end if
        end for
    else if m.tvDetails <> invalid and m.tvDetails.genres <> invalid
        for each genre in m.tvDetails.genres
            if genre.name <> invalid
                genreList.push(genre.name)
            end if
        end for
    end if

    if genreList.count() > 0
        allGenres = genreList.join(", ")
        metaParts.push(allGenres)
    end if

    m.metadataLabel.text = metaParts.join(" • ")
end sub

sub UpdateTagline()
    tagline = invalid
    if m.movieDetails <> invalid
        if m.movieDetails.tagline <> invalid and m.movieDetails.tagline <> ""
            tagline = m.movieDetails.tagline
        end if
    else if m.tvDetails <> invalid
        if m.tvDetails.tagline <> invalid and m.tvDetails.tagline <> ""
            tagline = m.tvDetails.tagline
        end if
    end if

    if tagline <> invalid
        m.taglineLabel.text = tagline
        m.taglineLabel.visible = true
    else
        m.taglineLabel.visible = false
    end if
end sub

sub CreateActionButtons()
    ' Clear existing buttons
    m.buttonsGroup.removeChildrenIndex(m.buttonsGroup.getChildCount(), 0)
    m.buttons = []

    ' Determine button states based on status
    hdStatus = invalid
    status4k = invalid
    if m.mediaInfo <> invalid
        hdStatus = m.mediaInfo.status
        status4k = m.mediaInfo.status4k
    end if

    ' Check for pending requests that can be cancelled
    pendingRequests = []
    if m.mediaInfo <> invalid and m.mediaInfo.requests <> invalid
        for each request in m.mediaInfo.requests
            ' Status 1 = pending (can be cancelled by user who created it)
            if request.status = 1
                pendingRequests.push(request)
            end if
        end for
    end if

    ' Get user's Jellyseerr permissions
    userPermissions = GetCurrentUserJellyseerrPermissions()
    mediaType = "movie"
    if m.mediaItem <> invalid and m.mediaItem.mediaType <> invalid
        mediaType = m.mediaItem.mediaType
    end if

    ' Check if user has 4K permission
    has4kPermission = CanRequest4K(userPermissions, mediaType)

    ' Determine if HD and 4K can be requested based on status
    ' Can request if status is null/1 (unknown), or 4 (partial)
    canRequestHDByStatus = (hdStatus = invalid or hdStatus = 1 or hdStatus = 4)
    canRequest4KByStatus = (status4k = invalid or status4k = 1 or status4k = 4)

    ' Combine status with permission
    userCanRequestHD = canRequestHDByStatus ' HD doesn't require special permission
    userCanRequest4K = canRequest4KByStatus and has4kPermission

    ' If both HD and 4K are requestable, show a single "Request" button that opens quality dialog
    if userCanRequestHD and userCanRequest4K
        addButton({ icon: "pkg:/images/icons/request_hd.png", label: "Request", action: "requestQuality", enabled: true })
    else
        ' Otherwise show individual buttons

        ' Request HD button
        ' Disable if pending (2), processing (3), or fully available (5)
        if hdStatus <> invalid and hdStatus >= 2 and hdStatus <> 4
            if hdStatus = 2
                addButton({ icon: "pkg:/images/icons/request_hd.png", label: "HD Pending", action: "none", enabled: false })
            else if hdStatus = 3
                addButton({ icon: "pkg:/images/icons/request_hd.png", label: "HD Processing", action: "none", enabled: false })
            else if hdStatus >= 5
                addButton({ icon: "pkg:/images/icons/request_hd.png", label: "HD Available", action: "none", enabled: false })
            end if
        else if userCanRequestHD
            ' Show "Request More" label if partially available (status 4)
            buttonLabel = "Request HD"
            if hdStatus = 4 then buttonLabel = "Request More (HD)"
            addButton({ icon: "pkg:/images/icons/request_hd.png", label: buttonLabel, action: "requestHD", enabled: true })
        end if

        ' Request 4K button
        ' Disable if pending (2), processing (3), or fully available (5)
        if status4k <> invalid and status4k >= 2 and status4k <> 4
            if status4k = 2
                addButton({ icon: "pkg:/images/icons/request_4k.png", label: "4K Pending", action: "none", enabled: false })
            else if status4k = 3
                addButton({ icon: "pkg:/images/icons/request_4k.png", label: "4K Processing", action: "none", enabled: false })
            else if status4k >= 5
                addButton({ icon: "pkg:/images/icons/request_4k.png", label: "4K Available", action: "none", enabled: false })
            end if
        else if userCanRequest4K
            ' Show "Request More" label if partially available (status 4)
            buttonLabel = "Request 4K"
            if status4k = 4 then buttonLabel = "Request More (4K)"
            addButton({ icon: "pkg:/images/icons/request_4k.png", label: buttonLabel, action: "request4K", enabled: true })
        end if
    end if

    ' Add Cancel Request button if there are pending requests
    if pendingRequests.count() > 0
        m.pendingRequests = pendingRequests
        addButton({ icon: "pkg:/images/icons/cancel.png", label: "Cancel Request", action: "cancelRequest", enabled: true })
    end if

    PositionButtons()
end sub

sub PositionButtons()
    ' Calculate button position based on overview text height
    ' overviewGroup is at Y=820
    ' overviewHeading takes ~40px, overviewText starts at +50 (Y=870)

    overviewGroupY = 820
    overviewTextOffset = 50
    textHeight = m.overviewText.boundingRect().height

    ' Add some padding between overview and buttons (40px)
    buttonY = overviewGroupY + overviewTextOffset + textHeight + 40

    ' Ensure minimum Y position to avoid overlapping with poster area
    if buttonY < 1040 then buttonY = 1040

    m.buttonsGroup.translation = [80, buttonY]

    ' Update cast section position to be below buttons (buttons are ~100px high)
    castY = buttonY + 140
    m.castHeading.getParent().translation = [80, castY]

    ' Update recommendations section position to be below cast (cast is ~450px high)
    recommendationsY = castY + 500
    m.recommendationsHeading.getParent().translation = [80, recommendationsY]

    ' Update similar section position to be below recommendations (recommendations row is ~450px high)
    similarY = recommendationsY + 500
    m.similarHeading.getParent().translation = [80, similarY]

    ' Update keywords section position to be below similar (similar row is ~450px high)
    keywordsY = similarY + 500
    m.keywordsSection.translation = [80, keywordsY]
end sub

sub addButton(config as object)
    buttonGroup = CreateObject("roSGNode", "Group")
    buttonGroup.focusable = config.enabled

    layoutGroup = CreateObject("roSGNode", "LayoutGroup")
    layoutGroup.layoutDirection = "vert"
    layoutGroup.horizAlignment = "center"
    layoutGroup.itemSpacings = [8]

    iconContainer = CreateObject("roSGNode", "Group")

    bgRect = CreateObject("roSGNode", "Poster")
    bgRect.uri = "pkg:/images/icons/info-box-bg-white.png"
    bgRect.loadDisplayMode = "scaleToFit"
    bgRect.width = 144
    bgRect.height = 72
    bgRect.translation = [-48, -12]
    bgRect.opacity = 0
    iconContainer.appendChild(bgRect)

    icon = CreateObject("roSGNode", "Poster")
    icon.uri = config.icon
    icon.width = 64
    icon.height = 64
    icon.translation = [-8, -8]
    if not config.enabled
        icon.opacity = 0.5
    end if
    iconContainer.appendChild(icon)

    layoutGroup.appendChild(iconContainer)

    label = CreateObject("roSGNode", "Label")
    label.text = config.label
    label.font = "font:SmallSystemFont"
    label.horizAlign = "center"
    if config.enabled
        label.color = "#CCCCCC"
    else
        label.color = "#666666"
    end if
    layoutGroup.appendChild(label)

    buttonGroup.appendChild(layoutGroup)

    buttonGroup.addField("buttonAction", "string", false)
    buttonGroup.buttonAction = config.action
    buttonGroup.addField("buttonIndex", "integer", false)
    buttonGroup.buttonIndex = m.buttons.count()
    buttonGroup.addField("bgRect", "node", false)
    buttonGroup.bgRect = bgRect
    buttonGroup.addField("iconNode", "node", false)
    buttonGroup.iconNode = icon
    buttonGroup.addField("labelNode", "node", false)
    buttonGroup.labelNode = label

    if config.enabled
        buttonGroup.observeField("focusedChild", "onButtonFocusChanged")
    end if

    m.buttonsGroup.appendChild(buttonGroup)
    m.buttons.push(buttonGroup)
end sub

sub onButtonFocusChanged(event as object)
    button = event.getRoSGNode()
    if button <> invalid and button.hasFocus()
        if button.bgRect <> invalid
            button.bgRect.opacity = 1.0
        end if
        if button.iconNode <> invalid
            button.iconNode.blendColor = "#666666"
        end if
        if button.labelNode <> invalid
            button.labelNode.color = "#FFFFFF"
        end if
    else
        if button.bgRect <> invalid
            button.bgRect.opacity = 0
        end if
        if button.iconNode <> invalid
            button.iconNode.blendColor = "#FFFFFF"
        end if
        if button.labelNode <> invalid
            button.labelNode.color = "#CCCCCC"
        end if
    end if
end sub

' Create keyword tags from movie or TV details
sub CreateKeywordsTags()
    ' Clear existing keyword buttons
    m.keywordsContainer.removeChildrenIndex(m.keywordsContainer.getChildCount(), 0)
    m.keywordButtons = []
    m.keywordRows = []
    m.focusedKeywordIndex = 0

    ' Get keywords from movie or TV details
    keywords = invalid
    mediaType = "movie"

    if m.movieDetails <> invalid and m.movieDetails.keywords <> invalid
        keywords = m.movieDetails.keywords
        mediaType = "movie"
    else if m.tvDetails <> invalid and m.tvDetails.keywords <> invalid
        keywords = m.tvDetails.keywords
        mediaType = "tv"
    end if

    ' Hide section if no keywords
    if keywords = invalid or type(keywords) <> "roArray" or keywords.count() = 0
        m.keywordsSection.visible = false
        return
    end if

    m.keywordsSection.visible = true
    m.keywordsHeading.visible = true

    ' Store media type for keyword selection
    m.keywordsMediaType = mediaType

    ' Layout configuration
    maxWidth = 1700 ' Maximum width before wrapping
    horizontalSpacing = 15 ' Space between keywords
    verticalSpacing = 12 ' Space between rows
    buttonHeight = 40
    paddingH = 20 ' Horizontal padding inside button

    currentX = 0
    currentY = 0
    currentRowIndices = []

    ' Create a temporary label to measure text width
    measureLabel = CreateObject("roSGNode", "Label")
    measureLabel.font = "font:SmallSystemFont"

    for i = 0 to keywords.count() - 1
        keyword = keywords[i]
        if keyword.id = invalid or keyword.name = invalid then continue for

        ' Measure text width
        measureLabel.text = keyword.name
        textBounds = measureLabel.boundingRect()
        buttonWidth = textBounds.width + (paddingH * 2)

        ' Check if we need to wrap to next row
        if currentX > 0 and currentX + buttonWidth > maxWidth
            ' Store current row and start new row
            if currentRowIndices.count() > 0
                m.keywordRows.push(currentRowIndices)
            end if
            currentRowIndices = []
            currentX = 0
            currentY = currentY + buttonHeight + verticalSpacing
        end if

        ' Create keyword button group
        buttonGroup = CreateObject("roSGNode", "Group")
        buttonGroup.translation = [currentX, currentY]
        buttonGroup.focusable = true

        ' Focus highlight (9-patch for proper scaling) - hidden by default
        focusPoster = CreateObject("roSGNode", "Poster")
        focusPoster.uri = "pkg:/images/hd_focus.9.png"
        focusPoster.width = buttonWidth
        focusPoster.height = buttonHeight
        focusPoster.blendColor = ColorPalette.WHITE
        focusPoster.visible = false
        focusPoster.opacity = 0
        buttonGroup.appendChild(focusPoster)

        ' Text label
        label = CreateObject("roSGNode", "Label")
        label.text = keyword.name
        label.font = "font:SmallSystemFont"
        label.color = "#D1D5DB" ' gray-300
        label.width = buttonWidth
        label.height = buttonHeight
        label.horizAlign = "center"
        label.vertAlign = "center"
        buttonGroup.appendChild(label)

        ' Store references for focus handling
        buttonGroup.addField("keywordId", "integer", false)
        buttonGroup.keywordId = keyword.id
        buttonGroup.addField("keywordName", "string", false)
        buttonGroup.keywordName = keyword.name
        buttonGroup.addField("buttonIndex", "integer", false)
        buttonGroup.buttonIndex = m.keywordButtons.count()
        buttonGroup.addField("focusPoster", "node", false)
        buttonGroup.focusPoster = focusPoster
        buttonGroup.addField("labelNode", "node", false)
        buttonGroup.labelNode = label

        m.keywordsContainer.appendChild(buttonGroup)
        m.keywordButtons.push(buttonGroup)
        currentRowIndices.push(m.keywordButtons.count() - 1)

        currentX = currentX + buttonWidth + horizontalSpacing
    end for

    ' Store final row
    if currentRowIndices.count() > 0
        m.keywordRows.push(currentRowIndices)
    end if
end sub

' Update keyword button focus visuals
sub updateKeywordFocus(index as integer, hasFocus as boolean)
    if index < 0 or index >= m.keywordButtons.count() then return

    button = m.keywordButtons[index]
    if button = invalid then return

    if hasFocus
        if button.focusPoster <> invalid
            button.focusPoster.visible = true
            button.focusPoster.opacity = 1.0
        end if
        if button.labelNode <> invalid then button.labelNode.color = "#FFFFFF"
    else
        if button.focusPoster <> invalid
            button.focusPoster.visible = false
            button.focusPoster.opacity = 0
        end if
        if button.labelNode <> invalid then button.labelNode.color = "#D1D5DB"
    end if
end sub

' Handle keyboard navigation within keywords section
function handleKeywordNavigation(key as string) as boolean
    if m.keywordButtons.count() = 0 then return false

    oldIndex = m.focusedKeywordIndex

    if key = "left"
        if m.focusedKeywordIndex > 0
            m.focusedKeywordIndex = m.focusedKeywordIndex - 1
            updateKeywordFocus(oldIndex, false)
            updateKeywordFocus(m.focusedKeywordIndex, true)
        end if
        return true
    else if key = "right"
        if m.focusedKeywordIndex < m.keywordButtons.count() - 1
            m.focusedKeywordIndex = m.focusedKeywordIndex + 1
            updateKeywordFocus(oldIndex, false)
            updateKeywordFocus(m.focusedKeywordIndex, true)
        end if
        return true
    else if key = "up"
        ' Find which row the current keyword is in
        currentRow = -1
        positionInRow = -1
        for rowIdx = 0 to m.keywordRows.count() - 1
            for colIdx = 0 to m.keywordRows[rowIdx].count() - 1
                if m.keywordRows[rowIdx][colIdx] = m.focusedKeywordIndex
                    currentRow = rowIdx
                    positionInRow = colIdx
                    exit for
                end if
            end for
            if currentRow >= 0 then exit for
        end for

        if currentRow > 0
            ' Move to previous row, try to maintain similar position
            prevRow = m.keywordRows[currentRow - 1]
            newPos = positionInRow
            if newPos >= prevRow.count() then newPos = prevRow.count() - 1
            m.focusedKeywordIndex = prevRow[newPos]
            updateKeywordFocus(oldIndex, false)
            updateKeywordFocus(m.focusedKeywordIndex, true)
            return true
        else
            ' At top row - let navigation escape to previous section
            return false
        end if
    else if key = "down"
        ' Find which row the current keyword is in
        currentRow = -1
        positionInRow = -1
        for rowIdx = 0 to m.keywordRows.count() - 1
            for colIdx = 0 to m.keywordRows[rowIdx].count() - 1
                if m.keywordRows[rowIdx][colIdx] = m.focusedKeywordIndex
                    currentRow = rowIdx
                    positionInRow = colIdx
                    exit for
                end if
            end for
            if currentRow >= 0 then exit for
        end for

        if currentRow >= 0 and currentRow < m.keywordRows.count() - 1
            ' Move to next row, try to maintain similar position
            nextRow = m.keywordRows[currentRow + 1]
            newPos = positionInRow
            if newPos >= nextRow.count() then newPos = nextRow.count() - 1
            m.focusedKeywordIndex = nextRow[newPos]
            updateKeywordFocus(oldIndex, false)
            updateKeywordFocus(m.focusedKeywordIndex, true)
            return true
        else
            ' At bottom row - no more rows, stay here
            return true
        end if
    else if key = "OK"
        ' Select the current keyword
        if m.focusedKeywordIndex >= 0 and m.focusedKeywordIndex < m.keywordButtons.count()
            button = m.keywordButtons[m.focusedKeywordIndex]
            if button <> invalid
                ' Navigate to browse by screen with keyword filter
                screen = CreateObject("roSGNode", "JellyseerrGenreBrowseScreen")
                screen.browseType = "keyword"
                screen.genreName = button.keywordName
                screen.mediaType = m.keywordsMediaType
                screen.genreId = button.keywordId
                m.global.sceneManager.callFunc("pushScene", screen)
                return true
            end if
        end if
    end if

    return false
end function

sub CreateMetadataFacts()
    m.metadataFactsGroup.removeChildrenIndex(m.metadataFactsGroup.getChildCount(), 0)

    facts = []

    if m.movieDetails <> invalid
        ' Status field may be string or integer
        if m.movieDetails.status <> invalid
            statusValue = m.movieDetails.status
            ' Convert to string if it's not already
            if type(statusValue) = "roString" or type(statusValue) = "String"
                if statusValue <> ""
                    facts.push({ label: "Status", value: statusValue })
                end if
            else if type(statusValue) = "roInt" or type(statusValue) = "roInteger" or type(statusValue) = "Integer"
                ' Skip numeric status codes
            end if
        end if

        if m.movieDetails.releaseDate <> invalid and m.movieDetails.releaseDate <> ""
            releaseDate = FormatReleaseDate(m.movieDetails.releaseDate)
            facts.push({ label: "Release Date", value: releaseDate })
        end if

        if m.movieDetails.runtime <> invalid and m.movieDetails.runtime > 0
            runtime = m.movieDetails.runtime
            hours = int(runtime / 60)
            minutes = runtime mod 60
            runtimeStr = ""
            if hours > 0 and minutes > 0
                runtimeStr = hours.toStr() + "h " + minutes.toStr() + "m"
            else if hours > 0
                runtimeStr = hours.toStr() + "h"
            else if minutes > 0
                runtimeStr = minutes.toStr() + "m"
            end if
            if runtimeStr <> ""
                facts.push({ label: "Runtime", value: runtimeStr })
            end if
        end if

        if m.movieDetails.budget <> invalid and m.movieDetails.budget > 0
            budgetStr = FormatCurrency(m.movieDetails.budget)
            facts.push({ label: "Budget", value: budgetStr })
        end if
    end if

    if m.tvDetails <> invalid
        if m.tvDetails.voteAverage <> invalid
            score = int(m.tvDetails.voteAverage * 10)
            facts.push({ label: "TMDB Score", value: score.toStr() + "%" })
        end if

        if m.tvDetails.status <> invalid and type(m.tvDetails.status) = "roString" and m.tvDetails.status <> ""
            facts.push({ label: "Status", value: m.tvDetails.status })
        end if

        if m.tvDetails.networks <> invalid and m.tvDetails.networks.count() > 0
            networkNames = []
            for each network in m.tvDetails.networks
                if network.name <> invalid
                    networkNames.push(network.name)
                end if
            end for
            if networkNames.count() > 0
                facts.push({ label: "Networks", value: networkNames.join(", ") })
            end if
        end if

        if m.tvDetails.firstAirDate <> invalid and m.tvDetails.firstAirDate <> ""
            firstAirDate = FormatReleaseDate(m.tvDetails.firstAirDate)
            facts.push({ label: "First Air Date", value: firstAirDate })
        end if

        if m.tvDetails.lastAirDate <> invalid and m.tvDetails.lastAirDate <> ""
            lastAirDate = FormatReleaseDate(m.tvDetails.lastAirDate)
            facts.push({ label: "Last Air Date", value: lastAirDate })
        end if

        if m.tvDetails.numberOfSeasons <> invalid
            facts.push({ label: "Seasons", value: m.tvDetails.numberOfSeasons.toStr() })
        end if
    end if

    if facts.count() > 0
        CreateMetadataGrid(facts)
    end if
end sub

sub CreateMetadataGrid(facts as object)
    ' Create a two-column grid container with rounded corners and borders
    ' Column 1: Header (label) | Column 2: Data (value)
    labelColumnWidth = 180
    valueColumnWidth = 300
    totalWidth = labelColumnWidth + valueColumnWidth
    cellHeight = 65
    borderColor = "#374151"
    borderWidth = 2

    ' Calculate grid dimensions
    numRows = facts.count()

    ' Create each row
    for i = 0 to numRows - 1
        fact = facts[i]
        yPos = i * cellHeight

        ' Create cell container
        cellGroup = CreateObject("roSGNode", "Group")
        cellGroup.translation = [0, yPos]

        ' Draw border lines
        ' Top border (only for first row)
        if i = 0
            topLine = CreateObject("roSGNode", "Rectangle")
            topLine.translation = [0, 0]
            topLine.width = totalWidth
            topLine.height = borderWidth
            topLine.color = borderColor
            cellGroup.appendChild(topLine)
        end if

        ' Left border
        leftLine = CreateObject("roSGNode", "Rectangle")
        leftLine.translation = [0, 0]
        leftLine.width = borderWidth
        leftLine.height = cellHeight
        leftLine.color = borderColor
        cellGroup.appendChild(leftLine)

        ' Right border
        rightLine = CreateObject("roSGNode", "Rectangle")
        rightLine.translation = [totalWidth - borderWidth, 0]
        rightLine.width = borderWidth
        rightLine.height = cellHeight
        rightLine.color = borderColor
        cellGroup.appendChild(rightLine)

        ' Center divider between columns
        dividerLine = CreateObject("roSGNode", "Rectangle")
        dividerLine.translation = [labelColumnWidth, 0]
        dividerLine.width = borderWidth
        dividerLine.height = cellHeight
        dividerLine.color = borderColor
        cellGroup.appendChild(dividerLine)

        ' Bottom border
        bottomLine = CreateObject("roSGNode", "Rectangle")
        bottomLine.translation = [0, cellHeight - borderWidth]
        bottomLine.width = totalWidth
        bottomLine.height = borderWidth
        bottomLine.color = borderColor
        cellGroup.appendChild(bottomLine)

        ' Header label (bold, left column)
        headerLabel = CreateObject("roSGNode", "Label")
        headerLabel.text = fact.label
        headerLabel.translation = [16, 18]
        headerLabel.font = "font:TinyBoldSystemFont"
        headerLabel.color = "#D1D5DB"
        headerLabel.width = labelColumnWidth - 32
        headerLabel.height = cellHeight - 36
        headerLabel.vertAlign = "center"
        cellGroup.appendChild(headerLabel)

        ' Value label (regular, right column)
        valueLabel = CreateObject("roSGNode", "Label")
        valueLabel.text = fact.value
        valueLabel.translation = [labelColumnWidth + 16, 18]
        valueLabel.font = "font:TinySystemFont"
        valueLabel.color = "#9CA3AF"
        valueLabel.width = valueColumnWidth - 32
        valueLabel.height = cellHeight - 36
        valueLabel.wrap = true
        valueLabel.maxLines = 2
        valueLabel.vertAlign = "center"
        cellGroup.appendChild(valueLabel)

        m.metadataFactsGroup.appendChild(cellGroup)
    end for
end sub

sub LoadCastData()
    if m.movieDetails = invalid and m.tvDetails = invalid
        return
    end if

    ' Safety check for cast data
    cast = []
    if m.movieDetails <> invalid and m.movieDetails.DoesExist("credits") and m.movieDetails.credits <> invalid and m.movieDetails.credits.DoesExist("cast") and m.movieDetails.credits.cast <> invalid
        cast = m.movieDetails.credits.cast
    else if m.tvDetails <> invalid and m.tvDetails.DoesExist("credits") and m.tvDetails.credits <> invalid and m.tvDetails.credits.DoesExist("cast") and m.tvDetails.credits.cast <> invalid
        cast = m.tvDetails.credits.cast
    end if

    if cast = invalid or cast.count() = 0
        m.castHeading.visible = false
        m.castRow.visible = false
        return
    end if

    castToShow = []
    maxCast = 20
    if cast.count() < maxCast then maxCast = cast.count()

    for i = 0 to maxCast - 1
        castToShow.push(cast[i])
    end for

    ' Create content nodes for cast
    castContent = CreateObject("roSGNode", "ContentNode")

    for each member in castToShow
        castNode = CreateObject("roSGNode", "ContentNode")
        castNode.title = member.name
        if member.character <> invalid
            castNode.description = member.character
        end if
        if member.profilePath <> invalid
            castNode.hdPosterUrl = "https://image.tmdb.org/t/p/w185" + member.profilePath
        end if
        ' Add person ID for details screen
        if member.id <> invalid
            castNode.addField("personId", "integer", false)
            castNode.personId = member.id
        end if
        castContent.appendChild(castNode)
    end for

    ' Make visible first, then set content - ItemGrid doesn't need wrapper ContentNode
    m.castHeading.visible = true
    m.castRow.visible = true
    m.castRow.content = castContent
end sub

sub LoadSimilarContent()
    ' Load similar movies or TV shows
    mediaType = m.mediaItem.mediaType
    if mediaType = invalid then mediaType = "movie"

    tmdbId = m.mediaItem.tmdbId
    endpoint = "/api/v1/" + mediaType + "/" + tmdbId.toStr() + "/similar"

    m.similarApiTask = CreateObject("roSGNode", "JellyseerrAPITask")
    m.similarApiTask.request = {
        method: "GET",
        endpoint: endpoint,
        queryParams: { page: "1" }
    }

    m.similarApiTask.observeField("response", "onSimilarContentResponse")
    m.similarApiTask.control = "RUN"
end sub

sub LoadRecommendationsContent()
    ' Load recommended movies or TV shows
    mediaType = m.mediaItem.mediaType
    if mediaType = invalid then mediaType = "movie"

    tmdbId = m.mediaItem.tmdbId
    endpoint = "/api/v1/" + mediaType + "/" + tmdbId.toStr() + "/recommendations"

    m.recommendationsApiTask = CreateObject("roSGNode", "JellyseerrAPITask")
    m.recommendationsApiTask.request = {
        method: "GET",
        endpoint: endpoint,
        queryParams: { page: "1" }
    }

    m.recommendationsApiTask.observeField("response", "onRecommendationsContentResponse")
    m.recommendationsApiTask.control = "RUN"
end sub

sub onRecommendationsContentResponse(event as object)
    response = event.getData()

    if not response.success or response.data = invalid
        m.recommendationsHeading.visible = false
        m.recommendationsRow.visible = false
        return
    end if

    results = response.data.results
    if results = invalid or results.count() = 0
        m.recommendationsHeading.visible = false
        m.recommendationsRow.visible = false
        return
    end if

    ' Take first 20 items
    itemsToShow = []
    maxItems = 20
    if results.count() < maxItems then maxItems = results.count()

    for i = 0 to maxItems - 1
        itemsToShow.push(results[i])
    end for

    ' Create content nodes for recommendations items
    recommendationsContent = CreateObject("roSGNode", "ContentNode")
    recommendationsRowNode = CreateObject("roSGNode", "ContentNode")

    for each item in itemsToShow
        mediaNode = CreateMediaContentNode(item)
        if mediaNode <> invalid
            recommendationsRowNode.appendChild(mediaNode)
        end if
    end for

    recommendationsContent.appendChild(recommendationsRowNode)

    ' Make visible first, then set content
    m.recommendationsHeading.text = "Recommendations"
    m.recommendationsHeading.visible = true
    m.recommendationsRow.visible = true
    m.recommendationsRow.content = recommendationsContent

    ' Force RowList to update
    m.recommendationsRow.content = m.recommendationsRow.content
end sub

sub onRecommendationsItemSelected(event as object)
    selectedIndex = event.getData()
    if selectedIndex.count() < 2 then return

    itemIndex = selectedIndex[1]
    row = m.recommendationsRow.content.getChild(0)
    if row = invalid then return

    selectedItem = row.getChild(itemIndex)
    if selectedItem = invalid then return

    ' Navigate to details screen for this item
    ShowJellyseerrDetails(selectedItem)
end sub

sub onSimilarContentResponse(event as object)
    response = event.getData()

    if not response.success or response.data = invalid
        m.similarHeading.visible = false
        m.similarRow.visible = false
        return
    end if

    results = response.data.results
    if results = invalid or results.count() = 0
        m.similarHeading.visible = false
        m.similarRow.visible = false
        return
    end if

    ' Take first 20 items
    itemsToShow = []
    maxItems = 20
    if results.count() < maxItems then maxItems = results.count()

    for i = 0 to maxItems - 1
        itemsToShow.push(results[i])
    end for

    ' Create content nodes for similar items
    similarContent = CreateObject("roSGNode", "ContentNode")
    similarRowNode = CreateObject("roSGNode", "ContentNode")

    for each item in itemsToShow
        mediaNode = CreateMediaContentNode(item)
        if mediaNode <> invalid
            similarRowNode.appendChild(mediaNode)
        end if
    end for

    similarContent.appendChild(similarRowNode)

    ' Make visible first, then set content - order matters for RowList
    ' Update heading text based on media type
    if m.mediaItem.mediaType = "tv"
        m.similarHeading.text = "Similar Series"
    else
        m.similarHeading.text = "Similar Movies"
    end if
    m.similarHeading.visible = true
    m.similarRow.visible = true
    m.similarRow.content = similarContent

    ' Force RowList to update by reassigning content (same as JellyseerrDiscoveryScreen)
    m.similarRow.content = m.similarRow.content
end sub

sub onSimilarItemSelected(event as object)
    selectedIndex = event.getData()
    if selectedIndex.count() < 2 then return

    itemIndex = selectedIndex[1]
    row = m.similarRow.content.getChild(0)
    if row = invalid then return

    selectedItem = row.getChild(itemIndex)
    if selectedItem = invalid then return

    ' Navigate to details screen for this item
    ShowJellyseerrDetails(selectedItem)
end sub

sub onCastItemSelected(event as object)
    selectedIndex = event.getData()

    ' MarkupGrid itemSelected returns integer index
    if selectedIndex = invalid or selectedIndex < 0
        return
    end if

    if m.castRow.content = invalid
        return
    end if

    selectedCast = m.castRow.content.getChild(selectedIndex)
    if selectedCast = invalid
        return
    end if

    ' Get person ID from the cast item
    personId = selectedCast.personId
    personName = selectedCast.title

    if personId = invalid or personId = 0
        return
    end if

    ' Navigate to cast details screen
    castDetailsScreen = CreateObject("roSGNode", "JellyseerrCastDetails")
    castDetailsScreen.personId = personId
    if personName <> invalid
        castDetailsScreen.personName = personName
    end if

    ' Store the currently focused element so we can restore it when coming back
    m.previousFocusedElement = m.focusedElement

    ' Add to THIS screen, not the scene
    m.top.appendChild(castDetailsScreen)
    castDetailsScreen.setFocus(true)
end sub

sub onRequestHDPressed()
    ' Check if user has advanced request permission
    userPermissions = GetCurrentUserJellyseerrPermissions()
    hasAdvancedPerm = HasAdvancedRequestPermission(userPermissions)

    if hasAdvancedPerm
        m.pendingQualitySelection = "hd"
        ShowAdvancedDialog("hd")
    else
        SubmitRequest(false)
    end if
end sub

sub onRequest4KPressed()
    ' Check if user has advanced request permission
    userPermissions = GetCurrentUserJellyseerrPermissions()
    hasAdvancedPerm = HasAdvancedRequestPermission(userPermissions)

    if hasAdvancedPerm
        m.pendingQualitySelection = "4k"
        ShowAdvancedDialog("4k")
    else
        SubmitRequest(true)
    end if
end sub

sub onRequestQualityPressed()
    ' Show quality selection dialog
    m.qualityDialog = CreateObject("roSGNode", "JellyseerrQualityDialog")

    ' Get current status values
    hdStatus = invalid
    status4k = invalid
    if m.mediaInfo <> invalid
        hdStatus = m.mediaInfo.status
        status4k = m.mediaInfo.status4k
    end if

    ' Pass status values for label/enabled state updates
    if hdStatus <> invalid
        m.qualityDialog.hdStatus = hdStatus
    end if
    if status4k <> invalid
        m.qualityDialog.status4k = status4k
    end if

    ' Get user's Jellyseerr permissions
    userPermissions = GetCurrentUserJellyseerrPermissions()
    mediaType = "movie"
    if m.mediaItem <> invalid and m.mediaItem.mediaType <> invalid
        mediaType = m.mediaItem.mediaType
    end if
    has4kPermission = CanRequest4K(userPermissions, mediaType)

    ' Calculate permission based on status AND user permission
    ' Can request if status is null/1 (unknown), or 4 (partial)
    userCanRequestHD = (hdStatus = invalid or hdStatus = 1 or hdStatus = 4)
    userCanRequest4K = (status4k = invalid or status4k = 1 or status4k = 4) and has4kPermission

    ' Pass permission values to dialog
    m.qualityDialog.canRequestHD = userCanRequestHD
    m.qualityDialog.canRequest4K = userCanRequest4K

    ' Observe for selection
    m.qualityDialog.observeField("selectedQuality", "onQualityDialogResponse")
    m.qualityDialog.observeField("wasCancelled", "onQualityDialogCancelled")

    ' Add to scene and focus
    m.top.getScene().appendChild(m.qualityDialog)
    m.qualityDialog.setFocus(true)
end sub

sub onQualityDialogResponse(event as object)
    selectedQuality = event.getData()


    ' Ignore empty selection (initial state)
    if selectedQuality = "" then return

    ' Close dialog
    if m.qualityDialog <> invalid
        m.qualityDialog.unobserveField("selectedQuality")
        m.qualityDialog.unobserveField("wasCancelled")
        m.top.getScene().removeChild(m.qualityDialog)
        m.qualityDialog = invalid
    end if

    ' Check if user has advanced request permission
    userPermissions = GetCurrentUserJellyseerrPermissions()
    hasAdvancedPerm = HasAdvancedRequestPermission(userPermissions)


    if hasAdvancedPerm
        ' Store the selected quality for later and show advanced dialog
        m.pendingQualitySelection = selectedQuality
        ShowAdvancedDialog(selectedQuality)
    else
        ' No advanced permission, submit directly with defaults
        if selectedQuality = "hd"
            SubmitRequest(false)
        else if selectedQuality = "4k"
            SubmitRequest(true)
        else if selectedQuality = "both"
            ' Submit HD first, then 4K after HD completes
            m.pending4kAfterHD = true
            SubmitRequest(false)
        end if
    end if
end sub

sub ShowAdvancedDialog(selectedQuality as string)
    mediaType = "movie"
    if m.mediaItem <> invalid and m.mediaItem.mediaType <> invalid
        mediaType = m.mediaItem.mediaType
    end if

    is4k = (selectedQuality = "4k")


    m.advancedDialog = CreateObject("roSGNode", "JellyseerrAdvancedDialog")
    m.advancedDialog.mediaType = mediaType
    m.advancedDialog.is4k = is4k

    m.advancedDialog.observeField("wasSubmitted", "onAdvancedDialogSubmitted")
    m.advancedDialog.observeField("wasCancelled", "onAdvancedDialogCancelled")

    m.top.getScene().appendChild(m.advancedDialog)
    m.advancedDialog.setFocus(true)
end sub

sub onAdvancedDialogSubmitted(event as object)
    wasSubmitted = event.getData()
    if not wasSubmitted then return

    ' Get the selected options
    serverId = m.advancedDialog.selectedServerId
    profileId = m.advancedDialog.selectedProfileId
    rootFolderPath = m.advancedDialog.selectedRootFolderPath


    ' Store advanced options for the request
    m.advancedOptions = {
        serverId: serverId,
        profileId: profileId,
        rootFolder: rootFolderPath
    }

    ' Close dialog
    if m.advancedDialog <> invalid
        m.advancedDialog.unobserveField("wasSubmitted")
        m.advancedDialog.unobserveField("wasCancelled")
        m.top.getScene().removeChild(m.advancedDialog)
        m.advancedDialog = invalid
    end if

    ' Restore focus to this screen
    m.top.setFocus(true)

    ' Now submit the request based on original quality selection
    selectedQuality = m.pendingQualitySelection
    if selectedQuality = "hd"
        SubmitRequestWithAdvancedOptions(false)
    else if selectedQuality = "4k"
        SubmitRequestWithAdvancedOptions(true)
    else if selectedQuality = "both"
        ' Submit HD first with advanced options, then 4K after HD completes
        m.pending4kAfterHD = true
        m.pending4kUseAdvancedOptions = true
        SubmitRequestWithAdvancedOptions(false)
    end if
end sub

sub onAdvancedDialogCancelled(event as object)
    wasCancelled = event.getData()
    if not wasCancelled then return

    ' Close dialog
    if m.advancedDialog <> invalid
        m.advancedDialog.unobserveField("wasSubmitted")
        m.advancedDialog.unobserveField("wasCancelled")
        m.top.getScene().removeChild(m.advancedDialog)
        m.advancedDialog = invalid
    end if

    ' Restore focus to this screen and button row
    m.top.setFocus(true)
    if m.buttons.count() > 0
        for each button in m.buttons
            if button.focusable
                button.setFocus(true)
                exit for
            end if
        end for
    end if
end sub

sub SubmitRequestWithAdvancedOptions(is4k as boolean)
    mediaType = m.mediaItem.mediaType
    if mediaType = invalid then mediaType = "movie"

    ' Check if it's a TV show with multiple seasons
    if mediaType = "tv" and m.tvDetails <> invalid and m.tvDetails.numberOfSeasons <> invalid
        numberOfSeasons = m.tvDetails.numberOfSeasons
        if numberOfSeasons > 1
            ' Store is4k and show season dialog
            m.pendingRequestIs4k = is4k
            m.useAdvancedOptions = true
            ShowSeasonDialog(is4k)
            return
        end if
    end if

    ' For movies or TV shows with 1 season, submit with advanced options
    SubmitRequestWithSeasonsAndOptions(invalid, is4k, m.advancedOptions)
end sub

sub onQualityDialogCancelled(event as object)
    wasCancelled = event.getData()
    if wasCancelled
        ' Close dialog
        if m.qualityDialog <> invalid
            m.qualityDialog.unobserveField("selectedQuality")
            m.qualityDialog.unobserveField("wasCancelled")
            m.top.getScene().removeChild(m.qualityDialog)
            m.qualityDialog = invalid
        end if

        ' Restore focus to button row
        if m.buttons.count() > 0
            for each button in m.buttons
                if button.focusable and button.buttonAction = "requestQuality"
                    button.setFocus(true)
                    exit for
                end if
            end for
        end if
    end if
end sub

sub onCancelRequestPressed()
    ' Show confirmation dialog before cancelling
    if m.pendingRequests = invalid or m.pendingRequests.count() = 0
        ShowMessage("No Requests", "There are no pending requests to cancel.")
        return
    end if

    ' Build description of what will be cancelled
    description = ""
    if m.pendingRequests.count() = 1
        request = m.pendingRequests[0]
        qualityType = "HD"
        if request.is4k = true then qualityType = "4K"
        description = "Cancel your pending " + qualityType + " request?"
    else
        description = "Cancel all " + m.pendingRequests.count().toStr() + " pending requests?"
    end if

    ' Create confirmation dialog
    dialog = CreateObject("roSGNode", "StandardMessageDialog")
    dialog.title = "Cancel Request"
    dialog.message = [description]
    dialog.buttons = ["Cancel Request", "Keep Request"]

    m.cancelConfirmDialog = dialog
    dialog.observeField("buttonSelected", "onCancelConfirmDialogResponse")
    m.top.getScene().dialog = dialog
end sub

sub onCancelConfirmDialogResponse(event as object)
    buttonIndex = event.getData()

    ' Close the dialog
    m.top.getScene().dialog = invalid
    m.cancelConfirmDialog.unobserveField("buttonSelected")
    m.cancelConfirmDialog = invalid

    ' Button 0 = "Cancel Request" (confirm), Button 1 = "Keep Request" (cancel)
    if buttonIndex = 0
        ' User confirmed - cancel all pending requests
        CancelPendingRequests()
    end if
end sub

sub CancelPendingRequests()
    if m.pendingRequests = invalid or m.pendingRequests.count() = 0
        return
    end if

    ShowLoading()

    ' Store pending requests count for status messages
    m.cancelRequestsRemaining = m.pendingRequests.count()
    m.cancelRequestsSuccess = 0
    m.cancelRequestsFailed = 0

    ' Cancel each pending request
    for each request in m.pendingRequests
        CancelSingleRequest(request.id)
    end for
end sub

sub CancelSingleRequest(requestId as integer)
    endpoint = "/api/v1/request/" + requestId.toStr()

    cancelTask = CreateObject("roSGNode", "JellyseerrAPITask")
    cancelTask.addField("requestId", "integer", false)
    cancelTask.requestId = requestId

    cancelTask.request = {
        method: "DELETE",
        endpoint: endpoint
    }

    cancelTask.observeField("response", "onCancelRequestResponse")
    cancelTask.control = "RUN"
end sub

sub onCancelRequestResponse(event as object)
    response = event.getData()
    ' Note: event.getRoSGNode() available if needed for request ID tracking

    m.cancelRequestsRemaining = m.cancelRequestsRemaining - 1

    if response.success
        m.cancelRequestsSuccess = m.cancelRequestsSuccess + 1
    else
        m.cancelRequestsFailed = m.cancelRequestsFailed + 1
    end if

    ' Check if all requests have been processed
    if m.cancelRequestsRemaining = 0
        HideLoading()

        ' Show result message and reload after dialog is dismissed
        if m.cancelRequestsFailed = 0
            if m.cancelRequestsSuccess = 1
                ShowSuccessAndReload("Request cancelled successfully.")
            else
                ShowSuccessAndReload(m.cancelRequestsSuccess.toStr() + " requests cancelled.")
            end if
        else if m.cancelRequestsSuccess = 0
            ShowMessage("Failed", "Failed to cancel request. You may not have permission.")
        else
            ' Partial success - still reload after dialog
            ShowSuccessAndReload(m.cancelRequestsSuccess.toStr() + " cancelled, " + m.cancelRequestsFailed.toStr() + " failed.")
        end if
    end if
end sub

sub SubmitRequest(is4k as boolean)
    mediaType = m.mediaItem.mediaType
    if mediaType = invalid then mediaType = "movie"

    ' Check if it's a TV show with multiple seasons
    if mediaType = "tv" and m.tvDetails <> invalid and m.tvDetails.numberOfSeasons <> invalid
        numberOfSeasons = m.tvDetails.numberOfSeasons

        ' If more than 1 season, show the dialog
        if numberOfSeasons > 1
            ShowSeasonDialog(is4k)
            return
        end if
    end if

    ' For movies or TV shows with 1 season, submit directly with all seasons
    SubmitRequestWithSeasons(invalid, is4k)
end sub

sub ShowSeasonDialog(is4k as boolean)
    ' Store is4k for later use
    m.pendingRequestIs4k = is4k

    ' Get show name
    showName = ""
    if m.tvDetails <> invalid
        if m.tvDetails.name <> invalid and m.tvDetails.name <> ""
            showName = m.tvDetails.name
        else if m.tvDetails.title <> invalid and m.tvDetails.title <> ""
            showName = m.tvDetails.title
        end if
    end if

    if showName = ""
        showName = m.mediaItem.title
        if showName = invalid then showName = "Unknown Show"
    end if

    numberOfSeasons = m.tvDetails.numberOfSeasons

    ' Get unavailable seasons (already requested/available for this quality)
    unavailableSeasons = GetUnavailableSeasons(is4k)

    ' Create season dialog
    m.seasonDialog = CreateObject("roSGNode", "JellyseerrSeasonDialog")
    m.seasonDialog.showName = showName
    m.seasonDialog.numberOfSeasons = numberOfSeasons
    m.seasonDialog.is4k = is4k
    m.seasonDialog.unavailableSeasons = unavailableSeasons

    ' Observe for response BEFORE setting any array fields
    m.seasonDialog.observeField("selectedSeasons", "onSeasonDialogResponse")
    m.seasonDialog.observeField("wasCancelled", "onSeasonDialogCancelled")

    ' Show dialog by adding to scene
    m.top.getScene().appendChild(m.seasonDialog)

    ' Explicitly set focus to the dialog
    m.seasonDialog.setFocus(true)
end sub

' Get set of season numbers that are already requested or available
' for the specified quality (HD or 4K)
function GetUnavailableSeasons(is4k as boolean) as object
    unavailableSeasons = []

    ' Check if we have mediaInfo with requests
    if m.mediaInfo = invalid then return unavailableSeasons
    if m.mediaInfo.requests = invalid then return unavailableSeasons

    ' Check existing requests for this quality
    for each request in m.mediaInfo.requests
        ' Only consider requests matching the quality (HD or 4K)
        requestIs4k = false
        if request.is4k <> invalid then requestIs4k = request.is4k
        if requestIs4k = is4k
            ' Only consider non-declined requests (status != 3)
            requestStatus = 0
            if request.status <> invalid then requestStatus = request.status
            if requestStatus <> 3
                ' Add all seasons from this request
                if request.seasons <> invalid and GetInterface(request.seasons, "ifArray") <> invalid
                    for each seasonRequest in request.seasons
                        if seasonRequest <> invalid and seasonRequest.seasonNumber <> invalid
                            unavailableSeasons.push(seasonRequest.seasonNumber)
                        end if
                    end for
                end if
            end if
        end if
    end for

    return unavailableSeasons
end function

sub onSeasonDialogResponse(event as object)
    selectedSeasons = event.getData()

    ' Ignore if we don't have a valid dialog or if selectedSeasons is not a valid array
    if m.seasonDialog = invalid then return
    if selectedSeasons = invalid or GetInterface(selectedSeasons, "ifArray") = invalid then return

    ' Check if array is actually populated with integers (not just empty on init)
    hasValidData = false
    if selectedSeasons.count() = 0
        ' Empty array is valid (means "all seasons")
        hasValidData = true
    else
        ' Check if first element is an integer
        if selectedSeasons.count() > 0 and GetInterface(selectedSeasons[0], "ifInt") <> invalid
            hasValidData = true
        end if
    end if

    if not hasValidData then return

    ' Unobserve and close dialog
    if m.seasonDialog <> invalid
        m.seasonDialog.unobserveField("selectedSeasons")
        m.seasonDialog.unobserveField("wasCancelled")
        m.top.getScene().removeChild(m.seasonDialog)
        m.seasonDialog = invalid
    end if

    ' Restore focus to this screen
    m.top.setFocus(true)

    ' Submit request with selected seasons
    ' Check if we should use advanced options
    if m.useAdvancedOptions = true and m.advancedOptions <> invalid
        SubmitRequestWithSeasonsAndOptions(selectedSeasons, m.pendingRequestIs4k, m.advancedOptions)
        m.useAdvancedOptions = false
    else
        SubmitRequestWithSeasons(selectedSeasons, m.pendingRequestIs4k)
    end if
end sub

sub onSeasonDialogCancelled(event as object)
    wasCancelled = event.getData()
    if wasCancelled
        ' Unobserve and close dialog
        if m.seasonDialog <> invalid
            m.seasonDialog.unobserveField("selectedSeasons")
            m.seasonDialog.unobserveField("wasCancelled")
            m.top.getScene().removeChild(m.seasonDialog)
            m.seasonDialog = invalid
        end if

        ' Restore focus to the details screen
        m.top.setFocus(true)
    end if
end sub

sub SubmitRequestWithSeasons(seasons as object, is4k as boolean)
    ShowLoading()

    ' Store is4k for error handling
    m.lastRequestIs4k = is4k

    mediaType = m.mediaItem.mediaType
    if mediaType = invalid then mediaType = "movie"

    ' Create request body with proper camelCase keys for API
    ' Note: We must build the JSON string manually to preserve camelCase
    requestBodyJson = "{"
    requestBodyJson = requestBodyJson + """mediaType"":""" + mediaType + """"
    requestBodyJson = requestBodyJson + ",""mediaId"":" + m.mediaItem.tmdbId.toStr()
    requestBodyJson = requestBodyJson + ",""is4k"":"
    if is4k
        requestBodyJson = requestBodyJson + "true"
    else
        requestBodyJson = requestBodyJson + "false"
    end if

    ' Handle seasons parameter for TV shows
    if mediaType = "tv"
        if seasons <> invalid and seasons.count() > 0
            ' Use selected seasons array
            requestBodyJson = requestBodyJson + ",""seasons"":["
            for i = 0 to seasons.count() - 1
                if i > 0 then requestBodyJson = requestBodyJson + ","
                ' Convert roInt to string - use itostr or just concatenate with empty string
                seasonNum = seasons[i]
                requestBodyJson = requestBodyJson + seasonNum.toStr()
            end for
            requestBodyJson = requestBodyJson + "]"
        else
            ' Request all seasons (empty array or invalid means "all")
            requestBodyJson = requestBodyJson + ",""seasons"":""all"""
        end if
    end if

    requestBodyJson = requestBodyJson + "}"

    endpoint = "/api/v1/request"

    ' Parse the JSON string back to an object for the API task
    requestBody = ParseJson(requestBodyJson)

    m.apiTask.request = {
        method: "POST",
        endpoint: endpoint,
        body: requestBody
    }

    m.apiTask.unobserveField("response")
    m.apiTask.observeField("response", "onRequestSubmitted")
    m.apiTask.control = "RUN"
end sub

' Submit request with advanced options (server, profile, root folder)
sub SubmitRequestWithSeasonsAndOptions(seasons as object, is4k as boolean, options as object)
    ShowLoading()

    ' Store is4k for error handling
    m.lastRequestIs4k = is4k

    mediaType = m.mediaItem.mediaType
    if mediaType = invalid then mediaType = "movie"

    ' Create request body with proper camelCase keys for API
    requestBodyJson = "{"
    requestBodyJson = requestBodyJson + """mediaType"":""" + mediaType + """"
    requestBodyJson = requestBodyJson + ",""mediaId"":" + m.mediaItem.tmdbId.toStr()
    requestBodyJson = requestBodyJson + ",""is4k"":"
    if is4k
        requestBodyJson = requestBodyJson + "true"
    else
        requestBodyJson = requestBodyJson + "false"
    end if

    ' Add advanced options if provided
    if options <> invalid
        if options.serverId <> invalid and options.serverId >= 0
            requestBodyJson = requestBodyJson + ",""serverId"":" + options.serverId.toStr()
        end if
        if options.profileId <> invalid and options.profileId > 0
            requestBodyJson = requestBodyJson + ",""profileId"":" + options.profileId.toStr()
        end if
        if options.rootFolder <> invalid and options.rootFolder <> ""
            requestBodyJson = requestBodyJson + ",""rootFolder"":""" + options.rootFolder + """"
        end if
    end if

    ' Handle seasons parameter for TV shows
    if mediaType = "tv"
        if seasons <> invalid and seasons.count() > 0
            requestBodyJson = requestBodyJson + ",""seasons"":["
            for i = 0 to seasons.count() - 1
                if i > 0 then requestBodyJson = requestBodyJson + ","
                seasonNum = seasons[i]
                requestBodyJson = requestBodyJson + seasonNum.toStr()
            end for
            requestBodyJson = requestBodyJson + "]"
        else
            requestBodyJson = requestBodyJson + ",""seasons"":""all"""
        end if
    end if

    requestBodyJson = requestBodyJson + "}"


    endpoint = "/api/v1/request"
    requestBody = ParseJson(requestBodyJson)

    m.apiTask.request = {
        method: "POST",
        endpoint: endpoint,
        body: requestBody
    }

    m.apiTask.unobserveField("response")
    m.apiTask.observeField("response", "onRequestSubmitted")
    m.apiTask.control = "RUN"
end sub

sub onRequestSubmitted(event as object)
    response = event.getData()
    HideLoading()

    qualityLabel = "HD"
    if m.lastRequestIs4k = true then qualityLabel = "4K"

    if response.success
        if m.pending4kAfterHD = true
            m.pending4kAfterHD = false
            if m.pending4kUseAdvancedOptions = true
                m.pending4kUseAdvancedOptions = false
                SubmitRequestWithAdvancedOptions(true)
            else
                SubmitRequest(true)
            end if
            return
        end if

        ' Show success message and reload after dialog is dismissed
        ShowSuccessAndReload(qualityLabel + " request submitted successfully!")
    else
        m.pending4kAfterHD = false
        m.pending4kUseAdvancedOptions = false

        errorMsg = "Failed to submit " + qualityLabel + " request"
        errorTitle = "Request Failed"

        ' Check if response has error field (from API task)
        if response.error <> invalid
            errType = type(response.error)
            if errType = "roString" or errType = "String"
                if response.error <> ""
                    errorMsg = response.error
                end if
            end if
        end if

        ' Handle specific error codes
        if response.statusCode = 403
            ' Simplified 403 permission error message (single line for better dialog display)
            errorTitle = "Permission Denied"
            errorMsg = "You don't have permission to request " + qualityLabel + " content. Contact your Jellyseerr administrator to adjust your permissions."
        else if response.statusCode = 400
            errorTitle = "Invalid Request"
            errorMsg = "Invalid request. Please check your Jellyseerr configuration."
        else
            ' Parse the rawResponse for error message
            if response.rawResponse <> invalid and response.rawResponse <> ""
                jsonError = ParseJson(response.rawResponse)
                if jsonError <> invalid
                    ' Safely extract error message as string
                    if jsonError.message <> invalid
                        msgType = type(jsonError.message)
                        if msgType = "roString" or msgType = "String"
                            if jsonError.message <> ""
                                errorMsg = errorMsg + ": " + jsonError.message
                            end if
                        end if
                    else if jsonError.error <> invalid
                        errType = type(jsonError.error)
                        if errType = "roString" or errType = "String"
                            if jsonError.error <> ""
                                errorMsg = errorMsg + ": " + jsonError.error
                            end if
                        end if
                    end if
                end if
            end if
        end if

        ShowMessage(errorTitle, errorMsg)
    end if
end sub

sub ShowMessage(title as string, message as dynamic)
    ' Initialize with a guaranteed string literal
    defaultMsg = "An error occurred"
    safeMessage = defaultMsg

    ' Ensure title is a valid string
    safeTitle = "Error"
    if title <> invalid
        titleType = type(title)
        if titleType = "roString" or titleType = "String"
            if title <> ""
                safeTitle = title
            end if
        end if
    end if

    ' Try to convert message to string
    if message <> invalid
        msgType = type(message)
        if msgType = "roString" or msgType = "String"
            ' Already a string - use directly but ensure not empty
            if message <> ""
                safeMessage = message
            end if
        else if msgType = "roInt" or msgType = "roInteger" or msgType = "Integer"
            ' Convert integer to string
            tempStr = Str(message).Trim()
            if tempStr <> ""
                safeMessage = tempStr
            end if
        else if msgType = "roBoolean" or msgType = "Boolean"
            ' Convert boolean to string
            if message = true
                safeMessage = "true"
            else
                safeMessage = "false"
            end if
        end if
    end if

    ' Create and show dialog with safe values
    dialog = CreateObject("roSGNode", "StandardMessageDialog")
    if dialog <> invalid
        ' Set properties individually with explicit string values
        dialog.title = safeTitle + "" ' Force string concatenation
        dialog.message = [safeMessage + ""] ' StandardMessageDialog expects an array of strings
        dialog.buttons = ["OK"]
        dialog.observeField("buttonSelected", "onMessageDialogClosed")

        scene = m.top.getScene()
        if scene <> invalid
            m.messageDialog = dialog
            scene.dialog = dialog
        end if
    end if
end sub

sub onMessageDialogClosed(_event as object)
    scene = m.top.getScene()
    if scene <> invalid
        scene.dialog = invalid
    end if

    if m.messageDialog <> invalid
        m.messageDialog.unobserveField("buttonSelected")
        m.messageDialog = invalid
    end if
end sub

' Show success message and reload details after dialog is dismissed
sub ShowSuccessAndReload(message as string)
    dialog = CreateObject("roSGNode", "StandardMessageDialog")
    if dialog <> invalid
        dialog.title = "Success"
        dialog.message = [message]
        dialog.buttons = ["OK"]
        dialog.observeField("buttonSelected", "onSuccessDialogClosed")

        scene = m.top.getScene()
        if scene <> invalid
            m.successDialog = dialog
            scene.dialog = dialog
        end if
    end if
end sub

sub onSuccessDialogClosed(_event as object)
    scene = m.top.getScene()
    if scene <> invalid
        scene.dialog = invalid
    end if

    if m.successDialog <> invalid
        m.successDialog.unobserveField("buttonSelected")
        m.successDialog = invalid
    end if

    ' Focus will be set by onFullDetailsResponse after reload completes
    LoadFullDetails()
end sub

sub ShowLoading()
    m.loadingLabel.visible = true
end sub

sub HideLoading()
    m.loadingLabel.visible = false
end sub

sub ShowError(message as string)
    if isValidAndNotEmpty(message)
        m.errorLabel.text = message
        m.errorLabel.visible = true
        m.loadingLabel.visible = false
    end if
end sub

function GetYearFromDate(dateString as dynamic) as dynamic
    if dateString = invalid or dateString = "" then return invalid
    ' Date format is typically YYYY-MM-DD
    if len(dateString) >= 4
        return Left(dateString, 4)
    end if
    return invalid
end function

function FormatReleaseDate(dateString as dynamic) as string
    if dateString = invalid or dateString = "" then return ""
    ' Date format is YYYY-MM-DD, convert to MMM DD, YYYY
    parts = dateString.split("-")
    if parts.count() = 3
        year = parts[0]
        month = parts[1].toInt()
        day = parts[2].toInt()

        monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        if month >= 1 and month <= 12
            return monthNames[month - 1] + " " + day.toStr() + ", " + year
        end if
    end if
    return dateString
end function

function FormatCurrency(amount as integer) as string
    if amount = invalid then return ""
    ' Format as $X,XXX,XXX
    amountStr = amount.toStr()
    formatted = "$"
    length = len(amountStr)

    for i = 0 to length - 1
        formatted = formatted + amountStr.mid(i, 1)
        remaining = length - i - 1
        if remaining > 0 and remaining mod 3 = 0
            formatted = formatted + ","
        end if
    end for

    return formatted
end function

function onKeyEvent(key as string, press as boolean) as boolean
    if not press then return false

    ' Update lastFocus when navigating within the screen
    if m.focusedElement <> invalid
        m.top.lastFocus = m.focusedElement
    end if

    ' Handle UP key to navigate to overhang when at button row
    if key = "up" and m.focusedElement <> invalid and m.focusedElement.isSameNode(m.buttonsGroup)
        return FocusOverhang(m.top)
    end if

    if key = "back"
        m.global.sceneManager.callFunc("popScene")
        return true
    end if

    ' Handle button selection with OK key
    if key = "OK" and m.focusedElement <> invalid and m.focusedElement.isSameNode(m.buttonsGroup)
        for each button in m.buttons
            if button.hasFocus() and button.buttonAction <> "none"
                if button.buttonAction = "requestHD"
                    onRequestHDPressed()
                else if button.buttonAction = "request4K"
                    onRequest4KPressed()
                else if button.buttonAction = "requestQuality"
                    onRequestQualityPressed()
                else if button.buttonAction = "cancelRequest"
                    onCancelRequestPressed()
                end if
                return true
            end if
        end for
    end if

    ' Handle left/right navigation between buttons
    if m.focusedElement <> invalid and m.focusedElement.isSameNode(m.buttonsGroup)
        if key = "left" or key = "right"
            return navigateButtons(key)
        end if
    end if

    ' Handle left/right/OK in keywords section
    if m.focusedElement <> invalid and m.focusedElement.isSameNode(m.keywordsContainer)
        if key = "left" or key = "right" or key = "OK"
            if handleKeywordNavigation(key)
                return true
            end if
        end if
    end if

    ' Handle vertical navigation
    if key = "down"
        return navigateDown()
    else if key = "up"
        return navigateUp()
    end if

    return false
end function

' Navigate left/right between action buttons
function navigateButtons(key as string) as boolean
    currentIndex = -1
    for i = 0 to m.buttons.count() - 1
        if m.buttons[i].hasFocus()
            currentIndex = i
            exit for
        end if
    end for

    if key = "left" and currentIndex > 0
        for i = currentIndex - 1 to 0 step -1
            if m.buttons[i].focusable
                m.buttons[i].setFocus(true)
                return true
            end if
        end for
    else if key = "right" and currentIndex >= 0 and currentIndex < m.buttons.count() - 1
        for i = currentIndex + 1 to m.buttons.count() - 1
            if m.buttons[i].focusable
                m.buttons[i].setFocus(true)
                return true
            end if
        end for
    end if

    return true
end function

' Navigate down through sections
function navigateDown() as boolean
    ' Get navigation order based on current position
    if m.focusedElement = invalid or m.focusedElement.isSameNode(m.buttonsGroup)
        return focusNextVisibleSection([m.castRow, m.recommendationsRow, m.similarRow, "keywords"])
    else if m.focusedElement.isSameNode(m.castRow)
        return focusNextVisibleSection([m.recommendationsRow, m.similarRow, "keywords"])
    else if m.focusedElement.isSameNode(m.recommendationsRow)
        return focusNextVisibleSection([m.similarRow, "keywords"])
    else if m.focusedElement.isSameNode(m.similarRow)
        return focusNextVisibleSection(["keywords"])
    else if m.focusedElement.isSameNode(m.keywordsContainer)
        return handleKeywordNavigation("down")
    end if

    return false
end function

' Navigate up through sections
function navigateUp() as boolean
    if m.focusedElement = invalid then return false

    if m.focusedElement.isSameNode(m.keywordsContainer)
        ' Try to navigate within keywords first
        if not handleKeywordNavigation("up")
            ' At top row - escape to previous section
            updateKeywordFocus(m.focusedKeywordIndex, false)
            return focusPreviousVisibleSection([m.similarRow, m.recommendationsRow, m.castRow, "buttons"])
        end if
        return true
    else if m.focusedElement.isSameNode(m.similarRow)
        return focusPreviousVisibleSection([m.recommendationsRow, m.castRow, "buttons"])
    else if m.focusedElement.isSameNode(m.recommendationsRow)
        return focusPreviousVisibleSection([m.castRow, "buttons"])
    else if m.focusedElement.isSameNode(m.castRow)
        return focusPreviousVisibleSection(["buttons"])
    end if

    return false
end function

' Focus the first visible section from the list (navigating down)
function focusNextVisibleSection(sections as object) as boolean
    for each section in sections
        if type(section) = "roString" or type(section) = "String"
            if section = "keywords" and m.keywordsSection.visible and m.keywordButtons.count() > 0
                return focusKeywordsSection()
            end if
        else if section <> invalid and section.visible
            return focusSection(section)
        end if
    end for
    return false
end function

' Focus the first visible section from the list (navigating up)
function focusPreviousVisibleSection(sections as object) as boolean
    for each section in sections
        if type(section) = "roString" or type(section) = "String"
            if section = "buttons" and m.buttons.count() > 0
                return focusButtonsSection()
            end if
        else if section <> invalid and section.visible
            return focusSection(section)
        end if
    end for
    return false
end function

' Focus a RowList section
function focusSection(section as object) as boolean
    ' Restore focus feedback on all RowLists when focusing a RowList
    setRowListFocusFeedback(true)
    m.focusedElement = section
    section.setFocus(true)
    ensureFocusedNodeVisible()
    return true
end function

' Focus the buttons section
function focusButtonsSection() as boolean
    ' Restore focus feedback on all RowLists
    setRowListFocusFeedback(true)
    m.focusedElement = m.buttonsGroup
    for each button in m.buttons
        if button.focusable
            button.setFocus(true)
            exit for
        end if
    end for
    ensureFocusedNodeVisible()
    return true
end function

' Focus the keywords section
function focusKeywordsSection() as boolean
    ' Clear focus from all RowLists first
    m.castRow.setFocus(false)
    m.recommendationsRow.setFocus(false)
    m.similarRow.setFocus(false)

    ' Hide focus feedback on all RowLists to prevent dual focus appearance
    setRowListFocusFeedback(false)

    m.focusedElement = m.keywordsContainer
    m.keywordsContainer.setFocus(true)
    m.focusedKeywordIndex = 0
    updateKeywordFocus(m.focusedKeywordIndex, true)
    ensureFocusedNodeVisible()
    return true
end function

' Enable or disable focus feedback on all RowLists
sub setRowListFocusFeedback(enabled as boolean)
    if m.castRow <> invalid then m.castRow.drawFocusFeedback = enabled
    if m.recommendationsRow <> invalid then m.recommendationsRow.drawFocusFeedback = enabled
    if m.similarRow <> invalid then m.similarRow.drawFocusFeedback = enabled
end sub

sub ensureFocusedNodeVisible()
    ' Get the currently focused element's position dynamically
    focusedY = 0
    focusedHeight = 150

    if m.focusedElement <> invalid
        if m.focusedElement.isSameNode(m.buttonsGroup)
            ' Get actual button position
            focusedY = m.buttonsGroup.translation[1]
            focusedHeight = 120
        else if m.focusedElement.isSameNode(m.castRow)
            ' Get actual cast section position
            castSection = m.castHeading.getParent()
            focusedY = castSection.translation[1]
            focusedHeight = 450
        else if m.focusedElement.isSameNode(m.recommendationsRow)
            ' Get actual recommendations section position
            recommendationsSection = m.recommendationsHeading.getParent()
            focusedY = recommendationsSection.translation[1]
            focusedHeight = 450
        else if m.focusedElement.isSameNode(m.similarRow)
            ' Get actual similar section position
            similarSection = m.similarHeading.getParent()
            focusedY = similarSection.translation[1]
            focusedHeight = 450
        else if m.focusedElement.isSameNode(m.keywordsContainer)
            ' Get actual keywords section position
            focusedY = m.keywordsSection.translation[1]
            focusedHeight = 200
        end if
    end if

    viewportHeight = 1080
    currentOffset = m.scrollOffset

    ' If focused item is below bottom edge, scroll down
    if focusedY + focusedHeight - currentOffset > viewportHeight
        delta = (focusedY + focusedHeight) - (currentOffset + viewportHeight)
        m.scrollOffset = m.scrollOffset + delta + 50
        ' If focused item is above top edge, scroll up
    else if focusedY - currentOffset < 100
        m.scrollOffset = focusedY - 100
    end if

    ' Clamp scrollOffset
    if m.scrollOffset < 0 then m.scrollOffset = 0

    ' Apply smooth scroll animation
    m.scrollContent.translation = [0, -m.scrollOffset]
end sub
