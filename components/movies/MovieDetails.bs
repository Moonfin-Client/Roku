import "pkg:/source/api/Image.bs"
import "pkg:/source/utils/config.bs"
import "pkg:/source/utils/misc.bs"

import "pkg:/source/enums/AnimationControl.bs"
import "pkg:/source/enums/AnimationState.bs"
import "pkg:/source/enums/ColorPalette.bs"
import "pkg:/source/enums/ImageType.bs"
import "pkg:/source/enums/KeyCode.bs"
import "pkg:/source/enums/MediaStreamType.bs"
import "pkg:/source/enums/PersonType.bs"
import "pkg:/source/enums/PlaybackMethod.bs"
import "pkg:/source/enums/String.bs"
import "pkg:/source/enums/SubtitleSelection.bs"
import "pkg:/source/enums/TaskControl.bs"
import "pkg:/source/enums/VideoType.bs"
import "pkg:/source/enums/ViewLoadStatus.bs"

sub init()
    m.global.queueManager.callFunc("setForceTranscode", PlaybackMethod.PLAYNORMALLY)

    ' Initialize rotation check flag
    m.performRotationCheck = true

    m.container = m.top.findnode("container")
    m.scrollableContent = m.top.findNode("scrollableContent")
    m.extrasGrid = m.top.findNode("extrasGrid")
    m.top.optionsAvailable = false

    m.options = m.top.findNode("movieOptions")
    m.audioSelector = m.top.findNode("audioSelector")
    m.subtitleSelector = m.top.findNode("subtitleSelector")

    ' Initialize task nodes for API calls
    m.favoriteTask = m.top.findNode("favoriteTask")
    m.playstateTask = m.top.findNode("playstateTask")

    ' Get references to info grid rows for visibility management
    m.genresRow = m.top.findNode("genresRow")
    m.directorRow = m.top.findNode("directorRow")
    m.writersRow = m.top.findNode("writersRow")
    m.runtimeRow = m.top.findNode("runtimeRow")
    m.endsRow = m.top.findNode("endsRow")

    ' Initialize button rows - only one will be visible at a time
    m.buttonRow = m.top.findNode("buttonRow")

    m.currentButtonIndex = 0
    m.buttonGroups = []
    m.buttons = []

    ' Set initial focus on first button
    ' Will be set after buttons are created dynamically

    m.loadStatus = ViewLoadStatus.INIT

    m.global.queueManager.callFunc("setLastKnownItemID", string.empty)

    m.top.observeField("itemContent", "itemContentChanged")

    ' Observe audio and subtitle selector changes
    m.audioSelector.observeField("audioStreamIndex", "onAudioStreamIndexChanged")
    m.subtitleSelector.observeField("subtitleStream", "onSubtitleStreamChanged")

    ' Observe visibility to restore focus when selectors are closed
    m.audioSelector.observeField("visible", "onAudioSelectorVisibleChanged")
    m.subtitleSelector.observeField("visible", "onSubtitleSelectorVisibleChanged")

    ' Observe scene manager return data for dialog responses
    m.global.sceneManager.observeField("dataReturned", "onDialogDataReturned")
end sub

' OnScreenShown: Callback function when view is presented on screen
'
sub OnScreenShown()
    ' set focus to button group
    if m.extrasGrid <> invalid and m.extrasGrid.isInFocusChain()
        m.top.lastFocus.setFocus(true)
        setLastFocus(m.top.lastFocus)
    else
        ' Focus on first visible button
        firstVisibleIndex = 0
        for i = 0 to m.buttonGroups.count() - 1
            if m.buttonGroups[i].visible
                firstVisibleIndex = i
                exit for
            end if
        end for

        if firstVisibleIndex < m.buttonGroups.count()
            m.currentButtonIndex = firstVisibleIndex
            m.buttonGroups[firstVisibleIndex].setFocus(true)
            highlightButton(firstVisibleIndex)
            setLastFocus(m.buttonGroups[firstVisibleIndex])
        end if
    end if

    if m.loadStatus = ViewLoadStatus.RELOAD
        if isChainValid(m.top.itemContent, "json.mediaStreams")
            SetDefaultAudioTrack(m.top.itemContent.json)
            SetUpAudioOptions(m.top.itemContent.json.mediaStreams)
        end if
        if isChainValid(m.top.itemContent, "json.mediaSources")
            SetUpVideoOptions(m.top.itemContent.json.mediaSources)
        end if
    end if

    if m.loadStatus = ViewLoadStatus.INIT
        m.loadStatus = ViewLoadStatus.FIRSTLOAD
        return
    end if

    m.loadStatus = ViewLoadStatus.RELOAD

    m.top.refreshMovieDetailsData = not m.top.refreshMovieDetailsData
end sub

sub onSelectedPartChanged()
    if not isValid(m.top.selectedPart) then return

    selectedPart = m.top.selectedPart
    m.global.queueManager.callFunc("setLastKnownItemID", selectedPart.id)

    ' Parts button not in new layout - functionality preserved via part selection

    m.loadStatus = ViewLoadStatus.FIRSTLOAD

    m.global.queueManager.callFunc("setLastKnownItemExtraType", string.EMPTY)
    m.top.refreshMovieDetailsData = not m.top.refreshMovieDetailsData
end sub

' setBackdropImage: If item has a backdrop image, use it as the background for the view
'
' @param {object} itemData - meta data for current item
sub setBackdropImage(itemData as object)
    ' For episodes, show the episode's backdrop behind everything
    if LCase(itemData.Type) = VideoType.EPISODE
        episodeBackgroundBlack = m.top.findNode("episodeBackgroundBlack")
        episodeBackdrop = m.top.findNode("episodeBackdrop")
        episodeBackdropTint = m.top.findNode("episodeBackdropTint")

        if isValid(episodeBackdrop)
            ' Determine which image to use - prefer backdrop, fall back to primary (screenshot)
            backdropUri = invalid
            if isValidAndNotEmpty(itemData.BackdropImageTags)
                ' Use backdrop image with blur
                backdropUri = ImageURL(itemData.id, ImageType.BACKDROP, {
                    "maxWidth": 1920,
                    "maxHeight": 1080,
                    "quality": 90,
                    "blur": 10,
                    "Tag": itemData.BackdropImageTags[0]
                })
            else if isChainValid(itemData, "ImageTags.Primary")
                ' Use primary image (screenshot) with blur as fallback
                backdropUri = ImageURL(itemData.id, ImageType.PRIMARY, {
                    "maxWidth": 1920,
                    "maxHeight": 1080,
                    "quality": 90,
                    "blur": 10,
                    "Tag": itemData.ImageTags.Primary
                })
            end if

            if isValid(backdropUri)
                ' Show backdrop elements
                if isValid(episodeBackgroundBlack)
                    episodeBackgroundBlack.visible = true
                end if
                episodeBackdrop.visible = true
                if isValid(episodeBackdropTint)
                    episodeBackdropTint.visible = true
                end if
                episodeBackdrop.uri = backdropUri
            end if
        end if
        return
    end if

    imageVersion = ImageType.BACKDROP
    imageTag = invalid

    ' For episodes, use the show's backdrop instead
    backdropItemId = itemData.id
    if LCase(itemData.Type) = VideoType.EPISODE and isValid(itemData.SeriesId)
        backdropItemId = itemData.SeriesId
    end if

    if isValidAndNotEmpty(itemData.BackdropImageTags)
        imageTag = itemData.BackdropImageTags[0]
    else if isChainValid(itemData, "ImageTags.Primary")
        imageVersion = ImageType.PRIMARY
        imageTag = itemData.ImageTags.Primary
    end if

    ' Return if no image available
    if not isValid(imageTag) then return

    ' Create a blank background so the user's background image doesn't bleed over
    movieBackground = m.top.findNode("movieBackground")
    if not isValid(movieBackground)
        movieBackground = createObject("roSGNode", "Rectangle")
    end if
    movieBackground.id = "movieBackground"
    movieBackground.width = "1920"
    movieBackground.height = "1080"
    movieBackground.color = "#000000"
    if not isValid(m.top.findNode("movieBackground"))
        m.top.insertChild(movieBackground, 0)
    end if

    movieBackdrop = m.top.findNode("movieBackdrop")
    if not isValid(movieBackdrop)
        movieBackdrop = createObject("roSGNode", "Poster")
    end if
    movieBackdrop.id = "movieBackdrop"
    movieBackdrop.loadDisplayMode = "scaleToFit"
    movieBackdrop.translation = "[0,0]"
    movieBackdrop.width = "1920"
    movieBackdrop.height = "1080"
    movieBackdrop.opacity = .3

    backdropUrl = ImageURL(backdropItemId, imageVersion, {
        "maxWidth": 1920,
        "maxHeight": 1080,
        "quality": 90,
        "blur": 10,
        "Tag": imageTag
    })
    movieBackdrop.uri = backdropUrl

    if not isValid(m.top.findNode("movieBackdrop"))
        m.top.insertChild(movieBackdrop, 1)
    end if

    ' Add color tint overlay for readability (same as Home screen)
    movieBackdropTint = m.top.findNode("movieBackdropTint")
    if not isValid(movieBackdropTint)
        movieBackdropTint = createObject("roSGNode", "Rectangle")
        movieBackdropTint.id = "movieBackdropTint"
        movieBackdropTint.width = "1920"
        movieBackdropTint.height = "1080"
        movieBackdropTint.color = "#F2000000"
        movieBackdropTint.opacity = 1.0
        m.top.insertChild(movieBackdropTint, 2)
    end if
end sub

' getStandardizedVideoQuality: Convert video height to standard quality labels
' @param {integer} height - video height in pixels
' @return {string} standardized quality string (4K, 1080p, 720p, 480p, SD)
' Rounds up to higher quality tier (e.g., 2000+ -> 4K, 1000+ -> 1080p)
function getStandardizedVideoQuality(height as integer) as string
    if height >= 2000
        return "4K"
    else if height >= 1000
        return "1080p"
    else if height >= 700
        return "720p"
    else if height >= 450
        return "480p"
    else
        return "SD"
    end if
end function

' getStandardizedAudioQuality: Convert audio channels to standard quality labels
' @param {integer} channels - number of audio channels
' @return {string} standardized audio quality string (7.1, 5.1, 2.0, etc)
function getStandardizedAudioQuality(channels as integer) as string
    if channels >= 8
        return "7.1"
    else if channels >= 6
        return "5.1"
    else if channels >= 2
        return "2.0"
    else
        return "1.0"
    end if
end function

' updateMetadataDots: Show/hide separator dots based on which metadata fields have content
sub updateMetadataDots()
    ' Get all metadata fields
    communityRatingNode = m.top.findNode("communityRating")
    criticRatingLabelNode = m.top.findNode("criticRatingLabel")
    releaseYearNode = m.top.findNode("releaseYear")
    officialRatingNode = m.top.findNode("officialRating")
    videoQualityNode = m.top.findNode("videoQuality")
    videoCodecNode = m.top.findNode("videoCodec")
    audioQualityNode = m.top.findNode("audioQuality")
    audioCodecNode = m.top.findNode("audioCodec")

    ' Helper to check if node has content
    hasContent = function(node as object) as boolean
        return isValid(node) and node.text <> ""
    end function

    ' Order: communityRating • criticRating • releaseYear • officialRating • videoQuality • videoCodec • audioQuality • audioCodec

    ' dot1: between communityRating and criticRating
    dot1 = m.top.findNode("dot1")
    if isValid(dot1)
        dot1.visible = hasContent(communityRatingNode) and hasContent(criticRatingLabelNode)
    end if

    ' dot2: between criticRating and releaseYear
    dot2 = m.top.findNode("dot2")
    if isValid(dot2)
        dot2.visible = hasContent(criticRatingLabelNode) and hasContent(releaseYearNode)
    end if

    ' dot3: between releaseYear and officialRating
    dot3 = m.top.findNode("dot3")
    if isValid(dot3)
        dot3.visible = hasContent(releaseYearNode) and hasContent(officialRatingNode)
    end if

    ' dot4: between officialRating and videoQuality
    dot4 = m.top.findNode("dot4")
    if isValid(dot4)
        dot4.visible = hasContent(officialRatingNode) and hasContent(videoQualityNode)
    end if

    ' dot5: between videoQuality and videoCodec
    dot5 = m.top.findNode("dot5")
    if isValid(dot5)
        dot5.visible = hasContent(videoQualityNode) and hasContent(videoCodecNode)
    end if

    ' dot6: between videoCodec and audioQuality
    dot6 = m.top.findNode("dot6")
    if isValid(dot6)
        dot6.visible = hasContent(videoCodecNode) and hasContent(audioQualityNode)
    end if

    ' dot7: between audioQuality and audioCodec
    dot7 = m.top.findNode("dot7")
    if isValid(dot7)
        dot7.visible = hasContent(audioQualityNode) and hasContent(audioCodecNode)
    end if
end sub

' setLogoImage: If item has a logo image, add it to the view
' setLogoImage: If item has a logo image, add it to the view
'
' @param {object} itemData - meta data for current item
sub setLogoImage(itemData as object)
    movieLogo = m.top.findNode("movieLogo")
    if not isValid(movieLogo) then return

    ' For episodes and series, don't show a logo
    if LCase(itemData.type) = VideoType.EPISODE or LCase(itemData.type) = VideoType.SERIES
        return
    end if

    ' No logo found
    if not isChainValid(itemData, "ImageTags.Logo")
        return
    end if

    movieLogo.visible = true
    movieLogo.uri = ImageURL(m.top.id, ImageType.LOGO, {
        "format": "Png",
        "maxHeight": 200,
        "maxWidth": 400,
        "Tag": itemData.ImageTags.Logo
    })
end sub

sub itemContentChanged()
    ' Updates video metadata
    item = m.top.itemContent

    if isvalid(m.extrasGrid)
        m.extrasGrid.seasonID = item.seasonID
        m.extrasGrid.showID = item.showID
        m.extrasGrid.episodeID = item.id
    end if

    if not isChainValid(item, "json")
        ' Show buttons even if no data
        if m.buttonRow <> invalid then m.buttonRow.visible = true
        stopLoadingSpinner()
        return
    end if

    itemData = item.json
    m.top.id = itemData.id

    ' Update play button text based on resume position
    playTextNode = m.top.findNode("playText")
    if itemData.UserData.PlaybackPositionTicks > 0
        if isValid(playTextNode)
            playTextNode.text = `${tr("Play")}`
        end if
    else
        if isValid(playTextNode)
            playTextNode.text = tr("Play")
        end if
    end if
    setWatchedColor()
    setFavoriteColor()

    ' Check for trailer availability
    hasTrailer = false
    if isValidAndNotEmpty(itemData.RemoteTrailers) or isValidAndNotEmpty(itemData.LocalTrailerCount)
        hasTrailer = true
    end if
    m.top.trailerAvailable = hasTrailer

    ' Update button visibility based on content
    updateButtonVisibility(itemData)

    ' We don't need to update everything if this is a reload
    ' Unless this is an episode
    if m.loadStatus = ViewLoadStatus.RELOAD
        if LCase(itemData.Type) <> VideoType.EPISODE
            return
        end if
    end if

    setBackdropImage(itemData)
    setLogoImage(itemData)

    ' Set default video source if user hasn't selected one yet
    if m.top.selectedVideoStreamId = "" and isValid(itemData.MediaSources)
        for i = 0 to itemData.mediaStreams.Count() - 1
            if itemData.mediaStreams[i].Type = "Video"
                m.options.codec = itemData.MediaStreams[i].Codec
                if isStringEqual(PlaybackMethod.FORCETRANSCODEDISABLEREMUX, chainLookupReturn(m.global.session, "user.settings.`playback.media.forceTranscode`", PlaybackMethod.PLAYNORMALLY))
                    m.global.queueManager.callFunc("setForceTranscode", PlaybackMethod.FORCETRANSCODEDISABLEREMUX, m.options.codec)
                    exit for
                end if
            end if
        end for

        m.top.selectedVideoStreamId = itemData.MediaSources[0].id
    end if

    ' Find first Audio Stream and set that as default
    SetDefaultAudioTrack(itemData)

    ' Handle all "As Is" fields

    ' Clear all metadata fields first
    setFieldText("releaseYear", "")
    setFieldText("officialRating", "")
    setFieldText("videoQuality", "")
    setFieldText("videoCodec", "")
    setFieldText("audioQuality", "")
    setFieldText("audioCodec", "")
    setFieldText("tagline", "")

    ' Show/hide different metadata based on content type
    if LCase(itemData.Type) = VideoType.SERIES
        ' TV Show: stars, year, status, rating
        setFieldText("releaseYear", itemData.productionYear)

        ' Show status if available
        if isValid(itemData.Status)
            setFieldText("officialRating", itemData.Status)
        else if isValid(itemData.officialRating)
            setFieldText("officialRating", itemData.officialRating)
        end if
    else if LCase(itemData.Type) = VideoType.EPISODE
        ' Episode: will be handled in separate section below
        ' Stars and metadata will be populated later
    else
        ' Movie: stars, tomato rating, release date, rating, video quality, codec, audio quality, codec
        ' Release year/date
        if isValid(itemData.PremiereDate)
            releaseDate = CreateObject("roDateTime")
            releaseDate.FromISO8601String(itemData.PremiereDate)
            setFieldText("releaseYear", releaseDate.AsDateString("short-month-no-weekday"))
        else if isValid(itemData.productionYear)
            setFieldText("releaseYear", itemData.productionYear)
        end if

        ' Rating (PG, R, etc)
        if isValid(itemData.officialRating)
            setFieldText("officialRating", itemData.officialRating)
        end if

        ' Video quality and codec from media streams
        if isValidAndNotEmpty(itemData.MediaStreams)
            for each stream in itemData.MediaStreams
                if LCase(stream.Type) = "video"
                    ' Video quality (resolution) - standardize to known formats
                    if isValid(stream.Height)
                        setFieldText("videoQuality", getStandardizedVideoQuality(stream.Height))
                    end if
                    ' Video codec
                    if isValid(stream.Codec)
                        setFieldText("videoCodec", UCase(stream.Codec))
                    end if
                    exit for
                end if
            end for

            ' Audio quality and codec
            for each stream in itemData.MediaStreams
                if LCase(stream.Type) = "audio"
                    ' Audio codec
                    if isValid(stream.Codec)
                        setFieldText("audioCodec", UCase(stream.Codec))
                    end if
                    ' Audio quality (channels)
                    if isValid(stream.Channels)
                        setFieldText("audioQuality", getStandardizedAudioQuality(stream.Channels))
                    end if
                    exit for
                end if
            end for
        end if

        ' Tagline in italics
        if isValid(itemData.Taglines) and isValidAndNotEmpty(itemData.Taglines)
            setFieldText("tagline", itemData.Taglines[0])
        end if
    end if

    ' Show/hide dots based on content visibility
    updateMetadataDots()

    criticRatingIcon = m.top.findNode("criticRatingIcon")

    if m.global.session.user.settings["ui.itemdetail.showRatings"]
        if isValid(itemData.communityRating)
            m.top.findNode("star").visible = true
            setFieldText("communityRating", int(itemData.communityRating * 10) / 10)
        else
            m.top.findNode("star").visible = false
            setFieldText("communityRating", "")
        end if

        if isValid(itemData.CriticRating)
            setFieldText("criticRatingLabel", stri(itemData.CriticRating).trim() + "%")
            if itemData.CriticRating > 60
                tomato = "pkg:/images/fresh.png"
            else
                tomato = "pkg:/images/rotten.png"
            end if
            if isValid(criticRatingIcon) then criticRatingIcon.uri = tomato
        else
            if isValid(criticRatingIcon) then criticRatingIcon.uri = ""
            setFieldText("criticRatingLabel", "")
        end if
    else
        if isValid(criticRatingIcon) then criticRatingIcon.uri = ""
        setFieldText("criticRatingLabel", "")
        setFieldText("communityRating", "")
        m.top.findNode("star").visible = false
    end if

    ' Update dot visibility after all ratings are set
    updateMetadataDots()

    if type(itemData.RunTimeTicks) = "LongInteger"
        setFieldText("runtime", getFormattedRuntime(itemData.RunTimeTicks))
        setFieldText("endsAt", tr("Ends at %1").Replace("%1", getEndTime(itemData.RunTimeTicks)))
        if isValid(m.runtimeRow) then m.runtimeRow.visible = true
        if isValid(m.endsRow) then m.endsRow.visible = true
    else
        if isValid(m.runtimeRow)
            m.runtimeRow.visible = false
            m.runtimeRow.height = 0
        end if
        if isValid(m.endsRow)
            m.endsRow.visible = false
            m.endsRow.height = 0
        end if
    end if

    ' Set movie/show title (hide for episodes)
    movieTitleNode = m.top.findNode("movieTitle")
    if LCase(itemData.Type) = VideoType.EPISODE
        if isValid(movieTitleNode) then movieTitleNode.visible = false
    else
        setFieldText("movieTitle", itemData.name)
        if isValid(movieTitleNode) then movieTitleNode.visible = true
    end if

    ' Set overview/description
    if m.global.session.user.settings["ui.itemdetail.showoverviewcontent"]
        setFieldText("overview", itemData.overview)
    end if

    ' Populate directors
    directors = []
    for each person in itemData.people
        if LCase(person.type) = PersonType.DIRECTOR
            directors.push(person.name)
        end if
    end for

    if isValidAndNotEmpty(directors)
        directorHeaderNode = m.top.findNode("directorHeader")
        if isValid(directorHeaderNode)
            directorHeaderNode.text = directors.Count() > 1 ? "Directors" : "Director"
        end if
        setFieldText("director", directors.join(", "))
        if isValid(m.directorRow) then m.directorRow.visible = true
    else
        if isValid(m.directorRow)
            m.directorRow.visible = false
            m.directorRow.height = 0
        end if
    end if

    ' Populate writers
    writers = []
    for each person in itemData.people
        if LCase(person.type) = "writer"
            writers.push(person.name)
        end if
    end for

    if isValidAndNotEmpty(writers)
        setFieldText("writers", writers.join(", "))
        if isValid(m.writersRow) then m.writersRow.visible = true
    else
        if isValid(m.writersRow)
            m.writersRow.visible = false
            m.writersRow.height = 0
        end if
    end if

    ' Populate genres
    if isValidAndNotEmpty(itemData.genres)
        setFieldText("genres", itemData.genres.join(", "))
        if isValid(m.genresRow) then m.genresRow.visible = true
    else
        if isValid(m.genresRow)
            m.genresRow.visible = false
            m.genresRow.height = 0
        end if
    end if

    ' Handle episodes differently
    if LCase(itemData.Type) = VideoType.EPISODE
        ' Build episode metadata: S#:E# • Date • Rating • Resolution • Video Codec • Audio Codec • Audio Quality
        episodeMetaParts = []

        ' Add S#:E# format
        if isAllValid([itemData.ParentIndexNumber, itemData.IndexNumber])
            episodeMetaParts.push("S" + itemData.ParentIndexNumber.toStr() + ":E" + itemData.IndexNumber.toStr())
        end if

        ' Add premiere date
        if isValid(itemData.PremiereDate)
            airDate = CreateObject("roDateTime")
            airDate.FromISO8601String(itemData.PremiereDate)
            episodeMetaParts.push(airDate.AsDateString("short-month-no-weekday"))
        end if

        ' Add rating
        if isValid(itemData.officialRating)
            episodeMetaParts.push(itemData.officialRating)
        end if

        ' Add resolution, video codec, audio codec if available
        if isValidAndNotEmpty(itemData.MediaStreams)
            for each stream in itemData.MediaStreams
                if LCase(stream.Type) = "video"
                    ' Add resolution - standardized
                    if isValid(stream.Height)
                        episodeMetaParts.push(getStandardizedVideoQuality(stream.Height))
                    end if
                    ' Add video codec
                    if isValid(stream.Codec)
                        episodeMetaParts.push(UCase(stream.Codec))
                    end if
                    exit for
                end if
            end for

            for each stream in itemData.MediaStreams
                if LCase(stream.Type) = "audio"
                    ' Add audio codec
                    if isValid(stream.Codec)
                        episodeMetaParts.push(UCase(stream.Codec))
                    end if
                    ' Add audio quality - standardized
                    if isValid(stream.Channels)
                        episodeMetaParts.push(getStandardizedAudioQuality(stream.Channels))
                    end if
                    exit for
                end if
            end for
        end if

        ' Set the metadata text
        setFieldText("releaseYear", episodeMetaParts.join(" • "))

        ' Hide official rating since it's in the metadata line
        setFieldText("officialRating", "")

        addEpisodeTitle(itemData)
    end if

    ' Calculate and display "Ends At" time
    calculateEndsAt(itemData)

    SetUpVideoOptions(itemData.mediaSources)
    SetUpAudioOptions(itemData.mediaStreams)

    ' Show buttons
    if m.buttonRow <> invalid
        m.buttonRow.visible = true
    end if
    stopLoadingSpinner()
end sub

sub addEpisodeTitle(itemData as object)
    episodeTitle = m.top.findNode("episodeTitle")

    if isValid(episodeTitle) and isValid(itemData.name)
        episodeTitle.text = itemData.name
        episodeTitle.visible = true
    end if
end sub

sub calculateEndsAt(itemData as object)
    ' Calculate what time the movie/show will end if started now
    endsAtNode = m.top.findNode("endsAt")
    if not isValid(endsAtNode) then return

    if isValid(itemData.RunTimeTicks) and itemData.RunTimeTicks > 0
        ' Get current time
        now = CreateObject("roDateTime")

        ' Convert RunTimeTicks to seconds (ticks are in 100-nanosecond units)
        runtimeSeconds = itemData.RunTimeTicks / 10000000

        ' Add runtime to current time
        endTime = CreateObject("roDateTime")
        endTime.FromSeconds(now.AsSeconds() + runtimeSeconds)
        endTime.ToLocalTime()

        ' Format as time string (e.g., "10:45 PM")
        endsAtNode.text = formatTime(endTime)
    else
        endsAtNode.text = "—"
    end if
end sub

sub SetUpVideoOptions(streams)
    videos = []

    for i = 0 to streams.Count() - 1
        if LCase(streams[i].VideoType) = VideoType.VIDEOFILE
            videoCodecForDisplay = ""
            codec = ""
            if isValidAndNotEmpty(streams[i].mediaStreams)

                ' find the first (default) video track to get the codec for the details screen

                for index = 0 to streams[i].mediaStreams.Count() - 1
                    if LCase(streams[i].mediaStreams[index].Type) = MediaStreamType.VIDEO
                        if m.performRotationCheck
                            rotation = chainLookupReturn(streams[i].mediaStreams[index], "rotation", 0)
                            if rotation <> 0
                                m.global.queueManager.callFunc("setForceTranscode", PlaybackMethod.FORCETRANSCODEALLOWREMUX)
                            end if
                        end if

                        exit for
                    end if
                end for

                videoCodecForDisplay = streams[i].mediaStreams[0].displayTitle
                codec = streams[i].mediaStreams[0].Codec
            end if

            ' Create options for user to switch between video tracks
            videos.push({
                "Title": streams[i].Name,
                "Description": tr("Video"),
                "Selected": m.top.selectedVideoStreamId = streams[i].id,
                "StreamID": streams[i].id,
                "video_codec": videoCodecForDisplay,
                "codec": codec
            })
        end if
    end for

    options = {}
    options.videos = videos
    m.options.options = options
end sub

sub SetUpAudioOptions(streams)
    preferredSubtitle = m.global.queueManager.callFunc("getPreferredSubtitleTrack")
    selectedSubtitle = isChainValid(preferredSubtitle, "StreamIndex") ? preferredSubtitle.StreamIndex : SubtitleSelection.NONE

    audioTracks = []
    subtitleTracks = [{
        "StreamIndex": SubtitleSelection.NONE,
        "json": {},
        "Title": "None",
        "Description": "None",
        "Selected": selectedSubtitle = SubtitleSelection.NONE
    }]

    audioStreamCount = 1
    for i = 0 to streams.Count() - 1
        if streams[i].Type = "Audio"
            rokuTrackName = `#uniq:${streams[i].LookupCI("Title") ?? string.EMPTY}(${audioStreamCount})`

            audioTracks.push({ "Title": streams[i].displayTitle, "Description": streams[i].Title, "Selected": m.top.selectedAudioStreamIndex = i, "StreamIndex": i, "RokuTrackName": rokuTrackName })
            audioStreamCount++
        end if
        if streams[i].Type = "Subtitle"
            subtitleTracks.push({ "Title": streams[i].displayTitle, "json": streams[i], "Description": streams[i].Title, "Selected": selectedSubtitle = streams[i].index, "StreamIndex": i })
        end if
    end for

    options = {}
    if isValid(m.options.options.videos)
        options.videos = m.options.options.videos
    end if
    options.audios = audioTracks
    options.subtitles = subtitleTracks
    m.options.options = options

end sub

sub SetDefaultAudioTrack(itemData)
    preferredAudioTrackIndex = m.global.queueManager.callFunc("getPreferredAudioTrackIndex")
    preferredAudioTrackName = m.global.queueManager.callFunc("getPreferredAudioTrackName")
    preferredLanguage = m.global.session.user.Configuration.AudioLanguagePreference
    firstAudioTrack = -1

    defaultAudioTrackIndex = getDefaultAudioTrackIndex(itemData.mediaStreams)
    defaultAudioTrackName = string.EMPTY

    ' If user has not selected an audio track and PlayDefaultAudioTrack setting is enabled, find the default track
    if preferredAudioTrackIndex < 0 and chainLookupReturn(m.global.session, "user.Configuration.PlayDefaultAudioTrack", false)
        preferredAudioTrackIndex = defaultAudioTrackIndex
    end if

    audioStreamCount = 1
    for i = 0 to itemData.mediaStreams.Count() - 1
        if itemData.mediaStreams[i].Type = "Audio"
            rokuTrackName = `#uniq:${itemData.mediaStreams[i].LookupCI("Title") ?? string.EMPTY}(${audioStreamCount})`

            if firstAudioTrack < 0 then firstAudioTrack = i

            if i = defaultAudioTrackIndex then defaultAudioTrackName = rokuTrackName

            if i = preferredAudioTrackIndex
                m.global.queueManager.callFunc("setPreferredAudioTrackName", rokuTrackName)
                preferredAudioTrackName = rokuTrackName
            end if

            ' No user selection and not configured to play the default, how about a preferred language?
            if preferredAudioTrackIndex < 0 and isValid(preferredLanguage)
                if isStringEqual(chainLookupReturn(itemData.mediaStreams[i], "Language", invalid), preferredLanguage)
                    m.top.selectedAudioStreamIndex = i
                    m.global.queueManager.callFunc("setPreferredAudioTrackName", rokuTrackName)
                    return
                end if
            end if

            if isStringEqual(rokuTrackName, preferredAudioTrackName)
                m.top.selectedAudioStreamIndex = i
                return
            end if

            audioStreamCount++
        end if
    end for

    if defaultAudioTrackIndex > -1
        m.top.selectedAudioStreamIndex = defaultAudioTrackIndex
        m.global.queueManager.callFunc("setPreferredAudioTrackName", defaultAudioTrackName)
        return
    end if

    ' If we got here, then nothing matched.  First track it is...
    if firstAudioTrack > -1
        m.top.selectedAudioStreamIndex = firstAudioTrack
    end if
end sub

sub setFieldText(field, value)
    node = m.top.findNode(field)
    if not isAllValid([node, value]) then return

    ' Handle non strings... Which _shouldn't_ happen, but hey
    if type(value) = "roInt" or type(value) = "Integer"
        value = str(value)
    else if type(value) = "roFloat" or type(value) = "Float"
        value = str(value)
    else if type(value) <> "roString" and type(value) <> "String"
        value = ""
    end if

    node.text = value
end sub

sub setFavoriteColor()
    fave = m.top.itemContent.favorite
    favoriteText = m.top.findNode("favoriteText")
    favoriteIcon = m.top.findNode("favoriteIcon")
    if not isValid(favoriteText) then return

    ' Initialize member variable for button visual state
    m.itemIsFavorited = (isValid(fave) and fave)

    if isValid(fave) and fave
        if isValid(favoriteIcon) then favoriteIcon.blendColor = ColorPalette.RED
        favoriteText.text = tr("Favorited")
    else
        if isValid(favoriteIcon) then favoriteIcon.blendColor = ColorPalette.WHITE
        favoriteText.text = tr("Favorite")
    end if
end sub

sub setWatchedColor()
    watched = m.top.itemContent.watched
    watchedText = m.top.findNode("watchedText")
    if not isValid(watchedText) then return

    if watched
        watchedText.text = tr("Watched")
    else
        watchedText.text = tr("Watched")
    end if
end sub

sub updateButtonVisibility(itemData as object)
    ' Clear existing buttons
    m.buttonRow.removeChildrenIndex(m.buttonRow.getChildCount(), 0)
    m.buttons = []
    m.buttonGroups = []

    ' Add buttons based on item type and conditions
    addButtons(itemData)

    ' Set focus to first button
    if m.buttonGroups.count() > 0
        m.currentButtonIndex = 0
        m.buttonGroups[0].setFocus(true)
        highlightButton(0)
    end if
end sub

sub addButtons(itemData as object)
    ' Resume / Play from beginning buttons (conditional - if playback started)
    hasProgress = false
    if isValid(itemData.UserData) and itemData.UserData.PlaybackPositionTicks > 0
        hasProgress = true
    end if

    if hasProgress
        ' Show resume button
        addButton({
            icon: "pkg:/images/icons/resume.png",
            label: "Resume",
            action: "resume",
            id: "resumeButton"
        })

        ' Show restart button
        addButton({
            icon: "pkg:/images/icons/restart.png",
            label: "Play from beginning",
            action: "restart",
            id: "restartButton"
        })
    else
        ' Show play button
        addButton({
            icon: "pkg:/images/icons/play.png",
            label: "Play",
            action: "play",
            id: "playButton"
        })
    end if

    ' Trailer button (conditional - only if trailers available)
    if m.top.trailerAvailable
        addButton({
            icon: "pkg:/images/icons/trailer.png",
            label: "Trailer",
            action: "trailer",
            id: "trailerButton"
        })
    end if

    ' Audio track button (conditional - only if multiple audio streams)
    hasMultipleAudio = false
    if isValid(itemData.MediaStreams)
        audioCount = 0
        for each stream in itemData.MediaStreams
            if stream.Type = "Audio"
                audioCount++
            end if
        end for
        if audioCount > 1
            hasMultipleAudio = true
        end if
    end if

    if hasMultipleAudio
        addButton({
            icon: "pkg:/images/icons/audio_track.png",
            label: "Audio",
            action: "audioTrack",
            id: "audioTrackButton"
        })
    end if

    ' Subtitle button (conditional - only if subtitle streams available)
    hasSubtitles = false
    if isValid(itemData.MediaStreams)
        for each stream in itemData.MediaStreams
            if stream.Type = "Subtitle"
                hasSubtitles = true
                exit for
            end if
        end for
    end if

    if hasSubtitles
        addButton({
            icon: "pkg:/images/icons/closed_captions.png",
            label: "Subtitles",
            action: "subtitleTrack",
            id: "subtitleButton"
        })
    end if

    ' Watched button - always visible
    addButton({
        icon: "pkg:/images/icons/watched.png",
        label: "Watched",
        action: "watched",
        id: "watchedButton"
    })

    ' Go to Series button (conditional - episodes only, always visible for episodes)
    isEpisode = LCase(itemData.Type) = VideoType.EPISODE
    if isEpisode
        addButton({
            icon: "pkg:/images/icons/go_to_series.png",
            label: "Go to Series",
            action: "goToSeries",
            id: "goToSeriesButton"
        })
    end if

    ' Favorite button - always visible
    addButton({
        icon: "pkg:/images/icons/favorite.png",
        label: "Favorite",
        action: "favorite",
        id: "favoriteButton"
    })

    ' More button - always visible
    addButton({
        icon: "pkg:/images/icons/more.png",
        label: "More",
        action: "more",
        id: "moreButton"
    })
end sub

sub addButton(config as object)
    ' Create button group with icon and label
    buttonGroup = CreateObject("roSGNode", "Group")
    buttonGroup.id = config.id

    ' Create a focusable rectangle for keyboard navigation
    focusRect = CreateObject("roSGNode", "Rectangle")
    focusRect.width = 100
    focusRect.height = 120
    focusRect.translation = [-50, 0]
    focusRect.color = "#00000000"
    focusRect.opacity = 0
    buttonGroup.appendChild(focusRect)

    ' Create layout group for icon and label
    layoutGroup = CreateObject("roSGNode", "LayoutGroup")
    layoutGroup.layoutDirection = "vert"
    layoutGroup.horizAlignment = "center"
    layoutGroup.itemSpacings = [8]

    ' Create icon container with background
    iconContainer = CreateObject("roSGNode", "Group")
    iconContainer.id = config.id + "IconContainer"

    ' Create background image (initially invisible) - wider rectangle
    bgRect = CreateObject("roSGNode", "Poster")
    bgRect.uri = "pkg:/images/icons/info-box-bg-white.png"
    bgRect.loadDisplayMode = "scaleToFit"
    bgRect.width = 144
    bgRect.height = 72
    bgRect.translation = [-48, -12]
    bgRect.opacity = 0
    bgRect.id = config.id + "Background"
    iconContainer.appendChild(bgRect)

    ' Create icon
    icon = CreateObject("roSGNode", "Poster")
    icon.uri = config.icon
    icon.width = 48
    icon.height = 48
    icon.id = config.id + "Icon"
    iconContainer.appendChild(icon)

    layoutGroup.appendChild(iconContainer)

    ' Create label
    label = CreateObject("roSGNode", "Text")
    label.text = config.label
    label.font = "font:SmallSystemFont"
    label.horizAlign = "center"
    label.color = "#CCCCCC"
    label.id = config.id + "Text"
    layoutGroup.appendChild(label)

    buttonGroup.appendChild(layoutGroup)

    ' Store action data and index
    buttonGroup.addField("buttonAction", "string", false)
    buttonGroup.buttonAction = config.action
    buttonGroup.addField("buttonIndex", "integer", false)
    buttonGroup.buttonIndex = m.buttons.count()

    ' Observe focus changes on the button itself
    buttonGroup.observeField("focusedChild", "onButtonFocusChanged")

    ' Add to button row
    m.buttonRow.appendChild(buttonGroup)
    m.buttons.push(buttonGroup)
    m.buttonGroups.push(buttonGroup)
end sub

sub updateButtonVisualState(buttonIndex as integer)
    ' Helper function to update button visual state without needing a focus event
    updateDetailButtonVisualState(m.buttonGroups, buttonIndex, m.itemIsFavorited, m.top.itemContent, "#AAAAAA")
end sub

sub onButtonFocusChanged(event as object)
    ' Update visual state when focus changes
    ' Note: Do NOT update m.currentButtonIndex here as this observer fires for both
    ' the button losing focus and gaining focus, causing the index to reset
    button = event.getRoSGNode()
    if button <> invalid and button.buttonIndex <> invalid
        ' Only update visual state if this button actually has focus
        if button.hasFocus() or button.isInFocusChain()
            updateButtonVisualState(button.buttonIndex)
        end if
    end if
end sub

'
'Check if options updated and any reloading required
sub audioOptionsClosed()
    if m.options.audioStreamIndex <> m.top.selectedAudioStreamIndex
        m.top.selectedAudioStreamIndex = m.options.audioStreamIndex
        m.global.queueManager.callFunc("setPreferredAudioTrackIndex", m.options.audioStreamIndex)
        m.global.queueManager.callFunc("setPreferredAudioTrackName", m.options.audioStreamName)
    end if

    restoreFocusToButtons()
end sub

sub onAudioStreamIndexChanged()
    ' Audio selector changed the audio stream
    if m.audioSelector.audioStreamIndex <> m.top.selectedAudioStreamIndex
        m.top.selectedAudioStreamIndex = m.audioSelector.audioStreamIndex
        m.global.queueManager.callFunc("setPreferredAudioTrackIndex", m.audioSelector.audioStreamIndex)
        m.global.queueManager.callFunc("setPreferredAudioTrackName", m.audioSelector.audioStreamName)
    end if
end sub

sub onSubtitleStreamChanged()
    ' Subtitle selector changed the subtitle stream
    if isValid(m.subtitleSelector.subtitleStream)
        m.global.queueManager.callFunc("setSubtitleTrack", m.subtitleSelector.subtitleStream)
    end if
end sub

' Restore focus when audio selector is closed
sub onAudioSelectorVisibleChanged()
    if not m.audioSelector.visible
        restoreFocusToButtons()
    end if
end sub

' Restore focus when subtitle selector is closed
sub onSubtitleSelectorVisibleChanged()
    if not m.subtitleSelector.visible
        restoreFocusToButtons()
    end if
end sub

sub restoreFocusToButtons()
    ' Restore focus to the currently selected button
    if m.buttonGroups.count() > 0 and m.currentButtonIndex >= 0 and m.currentButtonIndex < m.buttonGroups.count()
        m.buttonGroups[m.currentButtonIndex].setFocus(true)
        m.top.lastFocus = m.buttonGroups[m.currentButtonIndex]
        setLastFocus(m.buttonGroups[m.currentButtonIndex])
    end if
end sub

'
' Check if options were updated and if any reloding is needed...
sub videoOptionsClosed()
    if m.options.videoStreamId <> m.top.selectedVideoStreamId
        m.top.selectedVideoStreamId = m.options.videoStreamId
        ' Because the video stream has changed (i.e. the actual video)... we need to reload the audio stream choices for that video
        m.top.unobservefield("itemContent")
        itemData = m.top.itemContent.json
        for each mediaSource in itemData.mediaSources
            if mediaSource.id = m.top.selectedVideoStreamId
                itemData.mediaStreams = []
                for i = 0 to mediaSource.mediaStreams.Count() - 1
                    itemData.mediaStreams.push(mediaSource.mediaStreams[i])
                end for
                SetDefaultAudioTrack(itemData)
                SetUpAudioOptions(itemData.mediaStreams)
                exit for
            end if
        end for
        m.top.itemContent.json = itemData
        m.top.observeField("itemContent", "itemContentChanged")
    end if

    restoreFocusToButtons()

    ' If user manually disables force transcode, disable rotation check
    m.performRotationCheck = not isStringEqual(m.global.queueManager.callFunc("getForceTranscode"), PlaybackMethod.PLAYNORMALLY)
    if not m.performRotationCheck
        setFieldText("rotationWarning", string.EMPTY)
    end if
end sub

' onButtonGroupEscape removed - navigation handled in onKeyEvent

' onButtonItemFocused and onButtonItemUnfocused removed - focus handled by highlightButton()

function onKeyEvent(key as string, press as boolean) as boolean
    if not press then return false

    ' Handle navigation from extrasGrid back to buttons
    if key = KeyCode.UP and m.extrasGrid <> invalid and m.extrasGrid.isInFocusChain()
        if m.extrasGrid.itemFocused = 0
            ' Return to button row
            if m.buttonGroups.count() > 0
                m.buttonGroups[m.currentButtonIndex].setFocus(true)
                m.top.lastFocus = m.buttonGroups[m.currentButtonIndex]
                highlightButton(m.currentButtonIndex)
                setLastFocus(m.buttonGroups[m.currentButtonIndex])
                ' Scroll back to top
                if m.scrollableContent <> invalid
                    m.scrollableContent.translation = [0, 0]
                end if
                return true
            end if
        end if
        return false
    end if

    ' Handle button row navigation - check if any button has focus
    isButtonFocused = false
    if m.buttonGroups.count() > 0
        for each btn in m.buttonGroups
            if btn.hasFocus() or btn.isInFocusChain()
                isButtonFocused = true
                exit for
            end if
        end for
    end if

    if isButtonFocused
        if key = KeyCode.LEFT
            ' Navigate to previous button
            if m.currentButtonIndex > 0
                m.currentButtonIndex = m.currentButtonIndex - 1
                m.buttonGroups[m.currentButtonIndex].setFocus(true)
                m.top.lastFocus = m.buttonGroups[m.currentButtonIndex]
                return true
            end if
            return false
        else if key = KeyCode.RIGHT
            ' Navigate to next button
            if m.currentButtonIndex < m.buttonGroups.count() - 1
                m.currentButtonIndex = m.currentButtonIndex + 1
                m.buttonGroups[m.currentButtonIndex].setFocus(true)
                m.top.lastFocus = m.buttonGroups[m.currentButtonIndex]
                return true
            end if
            return false
        else if key = KeyCode.OK
            handleButtonSelect()
            return true
        else if key = KeyCode.DOWN
            ' Navigate to extrasGrid with smooth scroll
            if m.extrasGrid <> invalid and m.extrasGrid.content <> invalid
                m.extrasGrid.setFocus(true)
                m.top.lastFocus = m.extrasGrid
                setLastFocus(m.extrasGrid)
                ' Scroll content up to show extras
                if m.scrollableContent <> invalid
                    m.scrollableContent.translation = [0, -550]
                end if
            end if
            return true
        end if
    end if

    if key = KeyCode.BACK
        if m.options.visible = true
            m.options.visible = false
            videoOptionsClosed()
            audioOptionsClosed()
            return true
        end if

        if m.extrasGrid <> invalid and m.extrasGrid.isInFocusChain()
            ' Return to button row and scroll back up
            if m.buttonGroups.count() > 0
                m.buttonGroups[m.currentButtonIndex].setFocus(true)
                m.top.lastFocus = m.buttonGroups[m.currentButtonIndex]
                highlightButton(m.currentButtonIndex)
                group = m.global.sceneManager.callFunc("getActiveScene")
                group.lastFocus = m.buttonGroups[m.currentButtonIndex]
                ' Scroll content back to top
                if m.scrollableContent <> invalid
                    m.scrollableContent.translation = [0, 0]
                end if
            end if
            return true
        end if

        return false
    end if

    if key = KeyCode.PLAY and m.extrasGrid <> invalid and m.extrasGrid.hasFocus()
        if isValid(m.extrasGrid.focusedItem)
            m.top.quickPlayNode = m.extrasGrid.focusedItem
            return true
        end if

        return false
    end if

    return false
end function

' ============================================
' New Button Navigation Functions
' ============================================

sub highlightButton(index as integer)
    ' Highlight the button at the given index
    if index < 0 or index >= m.buttonGroups.count() then return

    for i = 0 to m.buttonGroups.count() - 1
        buttonGroup = m.buttonGroups[i]
        if buttonGroup = invalid then continue for

        ' Find the text child in the button group
        textNode = buttonGroup.findNode(buttonGroup.id.replace("ButtonGroup", "Text"))

        if i = index
            ' Highlighted button
            if textNode <> invalid and textNode.hasField("color")
                textNode.color = ColorPalette.HIGHLIGHT
            end if
        else
            ' Unhighlighted button
            if textNode <> invalid and textNode.hasField("color")
                textNode.color = "#CCCCCC"
            end if
        end if
    end for
end sub

sub handleButtonSelect()
    ' Handle button selection based on current index
    if m.currentButtonIndex < 0 or m.currentButtonIndex >= m.buttonGroups.count() then return

    buttonGroup = m.buttonGroups[m.currentButtonIndex]
    if buttonGroup = invalid then return

    ' Get the action from the dynamic button
    buttonAction = buttonGroup.buttonAction
    if buttonAction = invalid then return

    m.loadStatus = ViewLoadStatus.RELOAD

    ' Map button actions
    if buttonAction = "resume"
        ' Resume action - play from saved position without dialog
        startLoadingSpinner()
        itemContent = m.top.itemContent
        if itemContent <> invalid and isValid(itemContent.json)
            ' Get the saved playback position and set it as starting point
            playbackPositionTicks = chainLookup(itemContent, "json.UserData.PlaybackPositionTicks") ?? 0
            itemContent.startingPoint = playbackPositionTicks

            ' Set video and audio streams
            itemContent.id = m.top.selectedVideoStreamId
            itemContent.selectedAudioStreamIndex = m.top.selectedAudioStreamIndex

            ' Queue and play
            m.global.queueManager.callFunc("clear")
            m.global.queueManager.callFunc("push", itemContent)
            m.global.queueManager.callFunc("playQueue")
        end if
    else if buttonAction = "play"
        ' Play action - may show resume dialog if partially watched
        m.top.buttonSelected = "play-button"
    else if buttonAction = "restart"
        ' Play from beginning - reset position and play
        m.top.buttonSelected = "playFromBeginning-button"
    else if buttonAction = "trailer"
        ' Play trailer
        m.top.buttonSelected = "trailer-button"
    else if buttonAction = "audioTrack"
        ' Audio track selection - show dedicated audio selector
        if isValid(m.options.options) and isValid(m.options.options.audios)
            m.audioSelector.audioTracks = m.options.options.audios
            m.audioSelector.visible = true
            m.audioSelector.setFocus(true)
            setLastFocus(m.audioSelector)
        end if
    else if buttonAction = "subtitleTrack"
        ' Subtitle track selection - show dedicated subtitle selector
        if isValid(m.options.options) and isValid(m.options.options.subtitles)
            m.subtitleSelector.subtitleTracks = m.options.options.subtitles
            m.subtitleSelector.visible = true
            m.subtitleSelector.setFocus(true)
            setLastFocus(m.subtitleSelector)
        end if
    else if buttonAction = "watched"
        ' Toggle watched state
        itemContent = m.top.itemContent
        if itemContent <> invalid and isValid(itemContent.json)
            itemData = itemContent.json
            currentWatched = false
            if isValid(itemData.UserData) and isValid(itemData.UserData.Played)
                currentWatched = itemData.UserData.Played
            end if

            newWatchedState = not currentWatched

            ' Call API to update server using Task
            if newWatchedState
                date = CreateObject("roDateTime")
                dateStr = date.ToISOString()
                m.playstateTask.status = "markPlayed"
                m.playstateTask.itemId = itemData.id
                m.playstateTask.params = { "DatePlayed": dateStr, "PlaybackPositionTicks": 0 }
                m.playstateTask.control = TaskControl.RUN
                itemData.UserData.PlaybackPositionTicks = 0
            else
                m.playstateTask.status = "unmarkPlayed"
                m.playstateTask.itemId = itemData.id
                m.playstateTask.control = TaskControl.RUN
            end if

            ' Update local state
            itemData.UserData.Played = newWatchedState
            itemContent.watched = newWatchedState

            ' Update button visual state by refreshing current button focus
            if m.buttonGroups.count() > 0 and m.currentButtonIndex >= 0 and m.currentButtonIndex < m.buttonGroups.count()
                updateButtonVisualState(m.currentButtonIndex)
            end if
        end if
    else if buttonAction = "goToSeries"
        ' Navigate to the parent series from an episode
        m.top.buttonSelected = "goToSeries-button"
    else if buttonAction = "favorite"
        ' Toggle favorite state
        itemContent = m.top.itemContent
        if itemContent <> invalid and isValid(itemContent.json)
            itemData = itemContent.json
            currentFavorite = false
            if isValid(itemData.UserData) and isValid(itemData.UserData.IsFavorite)
                currentFavorite = itemData.UserData.IsFavorite
            end if

            newFavoriteState = not currentFavorite

            ' Call API to update server using Task
            if newFavoriteState
                m.favoriteTask.favTask = "favorite"
            else
                m.favoriteTask.favTask = "unfavorite"
            end if
            m.favoriteTask.itemId = itemData.id
            m.favoriteTask.control = TaskControl.RUN

            ' Update local state without triggering itemContent observers
            ' Store the favorite state separately to avoid re-rendering
            if not isValid(itemData.UserData)
                itemData.UserData = {}
            end if
            itemData.UserData.IsFavorite = newFavoriteState

            ' Store favorite state in a member variable for button visual updates
            m.itemIsFavorited = newFavoriteState

            ' Update button visual state to show red/white icon by refreshing current button focus
            if m.buttonGroups.count() > 0 and m.currentButtonIndex >= 0 and m.currentButtonIndex < m.buttonGroups.count()
                updateButtonVisualState(m.currentButtonIndex)
            end if
        end if
    else if buttonAction = "more"
        ' More options - show playback settings dialog
        showPlaybackSettingsDialog()
    end if
end sub

sub showPlaybackSettingsDialog()
    ' Create radio dialog with playback options
    dialogData = []

    ' Get current setting
    currentSetting = chainLookupReturn(m.global.session, "user.settings.`playback.media.forceTranscode`", PlaybackMethod.PLAYNORMALLY)

    ' Build options
    option1 = CreateObject("roSGNode", "ContentNode")
    option1.title = tr("Direct Play")
    option1.description = tr("Play files directly without transcoding")
    option1.id = PlaybackMethod.PLAYNORMALLY
    if isStringEqual(currentSetting, PlaybackMethod.PLAYNORMALLY)
        option1.selected = true
    end if
    dialogData.push(option1)

    option2 = CreateObject("roSGNode", "ContentNode")
    option2.title = tr("Force Transcode (Allow Remux)")
    option2.description = tr("Force transcoding, allow container remuxing")
    option2.id = PlaybackMethod.FORCETRANSCODEALLOWREMUX
    if isStringEqual(currentSetting, PlaybackMethod.FORCETRANSCODEALLOWREMUX)
        option2.selected = true
    end if
    dialogData.push(option2)

    option3 = CreateObject("roSGNode", "ContentNode")
    option3.title = tr("Force Transcode (Disable Remux)")
    option3.description = tr("Force full transcoding")
    option3.id = PlaybackMethod.FORCETRANSCODEDISABLEREMUX
    if isStringEqual(currentSetting, PlaybackMethod.FORCETRANSCODEDISABLEREMUX)
        option3.selected = true
    end if
    dialogData.push(option3)

    ' Show dialog
    m.global.sceneManager.callFunc("radioDialog", tr("Playback Settings"), dialogData)
end sub

' Handle dialog responses from SceneManager
sub onDialogDataReturned()
    returnData = m.global.sceneManager.returnData
    if not isValid(returnData) then return

    ' Check if this is a playback settings selection from RadioDialog
    if isValid(returnData.indexSelected) and returnData.indexSelected >= 0
        ' Get the selected option
        selectedIndex = returnData.indexSelected

        ' Map index to playback method
        if selectedIndex = 0
            ' Direct Play
            m.global.queueManager.callFunc("setForceTranscode", PlaybackMethod.PLAYNORMALLY)
        else if selectedIndex = 1
            ' Force Transcode (Allow Remux)
            m.global.queueManager.callFunc("setForceTranscode", PlaybackMethod.FORCETRANSCODEALLOWREMUX, string.EMPTY)
        else if selectedIndex = 2
            ' Force Transcode (Disable Remux)
            ' Get codec from current video if available
            codec = string.EMPTY
            if isValid(m.top.itemContent) and isChainValid(m.top.itemContent, "json.mediaSources")
                if m.top.itemContent.json.mediaSources.count() > 0
                    if isValidAndNotEmpty(m.top.itemContent.json.mediaSources[0].mediaStreams)
                        for each stream in m.top.itemContent.json.mediaSources[0].mediaStreams
                            if LCase(stream.Type) = MediaStreamType.VIDEO
                                codec = chainLookupReturn(stream, "Codec", string.EMPTY)
                                exit for
                            end if
                        end for
                    end if
                end if
            end if
            m.global.queueManager.callFunc("setForceTranscode", PlaybackMethod.FORCETRANSCODEDISABLEREMUX, codec)
        end if
    end if
end sub
